---
title: "MQ使用场景及JMS模型介绍"
date: 2020-08-16
draft: false
tags: ["使用介绍", "Java", "MQ"]
slug: "mq-and-JMS-introduction"
---

## MQ使用场景介绍
MQ（message queue），是分布式系统的重要组件，主要解决异步消息，应用解耦，消峰等问题。从而实现高可用，高性能，可伸缩和最终一致性的架构。
使用较多的mq有：activeMQ，rabbitMQ，Kafka，metaMQ。

 - **异步消息处理**
 可以将一些非核心流程，如日志，短信，邮件等，通过MQ的方式异步去处理。这样做的好处是缩短主流程的响应时间，提升用户体验。
 
 - **应用解耦合**
 商品服务和订单服务之间。用户下单后，订单服务会通知商品服务。不使用MQ的情况是订单服务调用商品服务的接口，这样订单服务和商品服务之间是耦合的；使用MQ，订单服务完成持久化处理，将消息写入MQ消息队列中，返回用户订单下单成功，商品服务来订阅这个下单的消息，采用拉或推的方式获得下单信息，商品服务根据商品下单信息进行商品库存信息修改，这样当下单时商品服务不可用时，也不影响正常下单，这就完成了订单服务和商品服务之间的解耦。
 
 - **流量消峰**
 秒杀活动流量过大，导致流量暴增，最终可能导致应用挂掉。一般会在应用前端加入消息队列来控制活动人数，假如消息队列超过最大数量，应该直接抛弃用户请求或者跳转到错误页面。秒杀业务根据消息队列中的请求信息在做后续的业务处理。比如在抢购时，可能一下子过来了10万个请求，但MQ只接受前100个用户的请求，超过100个不接收了。这样就成功限制了用户请求

## JMS消息模型
JMS 是基于 JVM 的消息代理规范，ActiveMQ、HornetMQ 是 JMS的实现。
JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。
Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。
我们可以简单的理解：两个应用程序之间需要进行通信，我们使用一个JMS服务，进行中间的转发，通过JMS 的使用，我们可以解除两个程序之间的耦合。

### 点对点模式
消息发送者发送消息，消息代理将其放入消息队列中，消息接受者从队列中获取消息，消息读取后被移除消息队列。
每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到它们被消费或超时。

p2p虽然可能有n个客户端在队列中侦听消息，但只有一个可以读取到消息，之后消息将不存在，其他人没法读取。
也就是说消息队列只有唯一一个发送者和 *接受者*，但是并不能说只有一个 *接收者*。
	 
特点：
- 每个消息只有一个消费者 (Consumer)（即一旦被消费，消息就不再在消息队列中）
- 发送者和接收者之间在时间上没有依赖性 ，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列。
- 接收者在成功接收消息之后需向队列应答成功  
	 
如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模型。

### 发布订阅模式
发布者将消息发送到 Topic，多个订阅者订阅这个主题，那么就会在消息到达的同时接收消息 

特点：
- 每个消息可以有多个消费者
- 发布者和订阅者之间有时间上的依赖性 。针对某个主题(Topic)的订阅者，它必须创建一个订阅之后，才能消费发布者的消息，而且，为了消费消息，订阅者 必须保持运行的状态。
当然，为了缓和这种严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。 
	
如果你希望发送的消息可以不被做任何处理、或者被一个消费者处理、或者可以被多个消费者处理 的话，那么可以采用Pub/Sub模型（也就是说发布者不关心有多少侦听者）。
	