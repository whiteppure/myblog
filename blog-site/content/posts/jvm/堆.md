---
title: "堆"
date: 2021-04-03
draft: false
tags: ["Java", "JVM"]
slug: "jvm-heap"
---

## 堆的核心概念
堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。
一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存的大小是可以调节的。
> -Xms10m：最小堆内存
>  
> -Xmx10m：最大堆内存

《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。

《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。
> The heap is the run-time data area from which memory for all class instances and arrays is allocated

“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。因为还有一些对象是在栈上分配的。

数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 也就是触发了GC的时候，才会进行回收
- 如果堆中对象马上被回收，那么用户线程就会收到影响，一个方法频繁的调用频繁的回收程序性能会收到影响

堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
![堆内存分配](/myblog/posts/images/essays/堆内存分配.png)

## 堆内存细分

![堆内存划分](/myblog/posts/images/essays/堆内存划分.png)

Java 7及之前**堆内存逻辑**上分为三部分：新生区+养老区+永久区

- Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Permanent Space永久区

Java 8及之后**堆内存逻辑**上分为三部分：新生区+养老区+元空间
- Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Meta Space 元空间

堆空间内部结构，JDK1.8之前从 永久代 替换成 元空间。
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8之前.png" alt="jvm1.8之前">
</div>
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8.png" alt="jvm1.8">
</div>


## 设置堆内存大小

Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项"-Xmx"和"-Xms"来进行设置。

> “-Xms"用于表示堆区的起始内存，等价于-xx:InitialHeapSize
  “-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize

*默认情况下,初始堆内存大小：物理电脑内存大小/64;最大堆内存大小：物理电脑内存大小/4*。

> 在生产环境和开发环境，通常会将-Xms和-Xmx两个参数配置相同的值，
其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

使用代码查看
```
public class MainTest {
    public static void main(String[] args) {
        // 返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        // 返回Java虚拟机试图使用的最大堆内存
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
        System.out.println("-Xms:" + initialMemory + "M");
        System.out.println("-Xmx:" + maxMemory + "M");
    }
}
```

## 查看堆内存大小

### -XX:+PrintGCDetails

程序启动加入`-XX:+PrintGCDetails`参数

![-XXPrintGCDetails](/myblog/posts/images/essays/-XXPrintGCDetails.png)

![-PrintGCDetails查看堆内存](/myblog/posts/images/essays/PrintGCDetails查看堆内存.png)


一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出`outOfMemoryError`异常。


## jstat -gc

> jps  ->  jstat -gc 进程ID

![jstat](/myblog/posts/images/essays/jstat.png)

