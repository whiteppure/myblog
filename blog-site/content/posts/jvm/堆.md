---
title: "堆"
date: 2021-04-03
draft: false
tags: ["Java", "JVM"]
slug: "jvm-heap"
---

## 堆的核心概念
堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。
一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存的大小是可以调节的。
> -Xms10m：最小堆内存
>  
> -Xmx10m：最大堆内存

《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。

《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。
> The heap is the run-time data area from which memory for all class instances and arrays is allocated

“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。因为还有一些对象是在栈上分配的。

数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 也就是触发了GC的时候，才会进行回收
- 如果堆中对象马上被回收，那么用户线程就会收到影响，一个方法频繁的调用频繁的回收程序性能会收到影响

堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
![堆内存分配](/myblog/posts/images/essays/堆内存分配.png)

## 堆内存细分

![堆内存划分](/myblog/posts/images/essays/堆内存划分.png)

Java 7及之前**堆内存逻辑**上分为三部分：新生区+养老区+永久区

- Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Permanent Space永久区

Java 8及之后**堆内存逻辑**上分为三部分：新生区+养老区+元空间
- Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Meta Space 元空间

堆空间内部结构，JDK1.8之前从 永久代 替换成 元空间。
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8之前.png" alt="jvm1.8之前">
</div>
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8.png" alt="jvm1.8">
</div>


## 设置堆内存大小

Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项"-Xmx"和"-Xms"来进行设置。

> “-Xms"用于表示堆区的起始内存，等价于 -XX:InitialHeapSize
  “-Xmx"则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize

![设置堆大小](/myblog/posts/images/essays/设置堆大小.png)

*默认情况下,初始堆内存大小：物理电脑内存大小/64;最大堆内存大小：物理电脑内存大小/4*。

> 在生产环境和开发环境，通常会将-Xms和-Xmx两个参数配置相同的值，
其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

使用代码查看
```
public class MainTest {
    public static void main(String[] args) {
        // 返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        // 返回Java虚拟机试图使用的最大堆内存
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
        System.out.println("-Xms:" + initialMemory + "M");
        System.out.println("-Xmx:" + maxMemory + "M");
    }
}
```

## 查看堆内存大小

### -XX:+PrintGCDetails

程序启动加入`-XX:+PrintGCDetails`参数

![-XXPrintGCDetails](/myblog/posts/images/essays/-XXPrintGCDetails.png)

![-PrintGCDetails查看堆内存](/myblog/posts/images/essays/PrintGCDetails查看堆内存.png)


### jstat -gc

> jps  ->  jstat -gc 进程ID

![jstat](/myblog/posts/images/essays/jstat.png)

## OOM
一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出`outOfMemoryError`异常。

代码实现
```
public class MainTest {
    public static void main(String[] args) {
        ArrayList<Object> list = new ArrayList<>();
        while (true){
//            try {
//                Thread.sleep(1000000);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
            list.add(new Picture(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Picture {
    private int data;
    public Picture(int data) {
        this.data = data;
    }
}
```
![OOM](/myblog/posts/images/essays/OOM.png)


> `jvisual` 工具在 jdk /bin/jvisualvm.exe 
亦可在编译器 [下载jvisual插件](https://blog.csdn.net/qq_37960603/article/details/85224547)

出现OOM错误后，可以通过 VisualVM 这个工具查看具体是什么参数造成的
![jvisual-OOM](/myblog/posts/images/essays/jvisual-OOM.png)


## 年轻代与老年代

存储在JVM中的Java对象，按照生命周期可以被划分为两类：

一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，生命周期短的，及时回收；
另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。

Java堆区进一步细分的话，可以划分为年轻代和老年代。
其中年轻代又可以划分为Eden区、Survivor0区和 Survivor1 区（有时也叫做from区、to区）。
![年轻代与老年代](/myblog/posts/images/essays/年轻代与老年代.png)

> 没有明确规定，to 区是 Survivor1；这两个区域是不断进行交换的；是从一个区到另外一个区

测试用的代码,用于测试以下JVM参数
```
public class MainTest {
    public static void main(String[] args) {
        System.out.println("start ...");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### -XX:NewRatio

该参数是配置新生代与老年代在堆结构的占比。

默认情况下，新生代：老年代 - > 1 : 2
- 默认-XX:NewRatio=2；表示新生代占1，老年代占2，新生代占整个堆的1/3
- 可以修改-XX:NewRatio=4； 表示新生代占1，老年代占4，新生代占整个堆的1/5
![NewRatio](/myblog/posts/images/essays/NewRatio.png)

当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整年轻代与老年代的比例，来进行调优。

### -XX:SurvivorRatio
该命令是调整eden区与survivor区比例。这个参数一般使用默认值就可以了。

在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，
当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如：-XX:SurvivorRatio=8。

> PS 在实际开发中使用hotspot虚拟机，默认情况下不是8：1：1；
是因为虚拟机有一个自适应内存分配策略，可以通过`-XX:-UseAdaptiveSizePolicy`关闭再来进行查看.
![SurvivorRatio](/myblog/posts/images/essays/SurvivorRatio.png)

几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）

IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。

可以使用选项"-Xmn"设置新生代最大内存大小。
> PS 当 -Xmn 参数与 -XX:NewRatio 设置的值发生冲突时，会以 -Xmn 设置的具体值为准。

![eden与survivor与tenured](/myblog/posts/images/essays/eden与survivor与tenured.png)

## 为对象分配内存
为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，
并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

对象分配内存步骤：
![对象内存分配策略](/myblog/posts/images/essays/对象内存分配策略.png)

1. 新的对象先放伊甸园区。此区有大小限制。(如果对象过大可能直接分配在老年代)
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行MinorGC，将伊甸园区中的不再被其他对象所引用的对象进行销毁。
再将新的对象放到伊甸园区。
3. 然后将伊甸园中的剩余对象移动到幸存者0区。
4. 如果再次触发MinorGC，会首先将没有被回收的对象放到幸存者1区，然后判断幸存者0区中的对象是否能被回收，如果没有回收，就会放到幸存者1区。
5. 重复步骤3、4，默认情况下如果一个对象被扫描了15次（阈值），都不能被回收，则将该对象晋升到老年代。
6. 当老年代内存不足时，再次触发GC：Major GC，进行老年代的内存清理。
7. 若老年代执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM错误。

*可以用 -XX:MaxTenuringThreshold=N  进行设置幸存者区到老年代的GC扫描次数，默认15次。*


> PS 如果幸存者区满了？
如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。
**需要特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作**

代码演示对象分配过程
```
// -Xms600m -Xmx600m
public class HeapInstanceTest {
    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];
    public static void main(String[] args) throws InterruptedException {
        ArrayList<HeapInstanceTest> list = new ArrayList<>();
        while (true) {
            list.add(new HeapInstanceTest());
            Thread.sleep(10);
        }
    }
}
```
打开`VisualVM`图形化界面,通过`VisualGC`进行动态化查看
![代码演示对象分配过程](/myblog/posts/images/essays/代码演示对象分配过程.gif)

> 总结： 
>- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to区
>- 关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集
>- 新生代采用复制算法的目的：是为了减少内碎片

## GC简单介绍

- Minor GC：新生代的GC
- Major GC：老年代的GC
- Full GC：整堆收集，收集整个Java堆和方法区的垃圾

JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现 STW 的问题；
而 Major GC 和 Full GC出现 STW 的时间，是Minor GC的10倍以上。
> STW: Java中 Stop-The-World 机制简称 STW ，是在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。
Java中一种全局暂停现象，全局停顿，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互；这些现象多半是由于 GC 引起。

JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。

针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）。

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
   - 新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集
   - 老年代收集（MajorGC/OldGC）：只是老年代的圾收集。目前，只有CMSGC会有单独收集老年代的行为。注意，很多时候Major GC会和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收。
    - 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为
- 整堆收集（FullGC）：收集整个Java堆和方法区的垃圾收集。

### Minor GC
当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满了不会引发Minor GC。每次Minor GC会清理年轻代的垃圾。
因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。

Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

### Major GC
发生在老年代的GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了。

出现了MajorGc，经常会伴随至少一次的Minor GC，但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程。

也就是在老年代空间不足时，会先尝试触发MinorGc。
如果之后空间还不足，则触发Major GC，Major GC的速度一般会比MinorGc慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了。

### Full GC
触发Full GC执行的情况有如下五种：

1. 调用`System.gc（）`时，系统建议执行Full GC，但是不必然执行.
2. 老年代空间不足.
    - 通过Minor GC后进入老年代的平均大小，大于老年代的可用内存.也就是老年代空间不足。
    - 由Eden区、survivor space（From Space）区向survivor space（To Space）区复制时，对象大小大于To Space可用内存，
    则把该对象转存到老年代，且老年代的可用内存小于该对象大小. 也就是老年代空间不足。
3. 方法区空间不足.

### GC举例
测试GC代码
```
public class MainTest {
    public static void main(String[] args) {
        int i = 0;
        try {
            List<String> list = new ArrayList<>();
            String a = "awsl";
            while(true) {
                list.add(a);
                a = a + a;
                i++;
            }
        }catch (Exception e) {
            e.getStackTrace();
        }
    }
}
```

加入如下虚拟机参数
```
-Xms10m -Xmx10m -XX:+PrintGCDetails
```

GC 日志
```
[GC (Allocation Failure) [PSYoungGen: 1933K->496K(2560K)] 1933K->736K(9728K), 0.0009799 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2476K->480K(2560K)] 2716K->1464K(9728K), 0.0014628 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
[Full GC (Ergonomics) [PSYoungGen: 2156K->0K(2560K)] [ParOldGen: 7128K->4559K(7168K)] 9284K->4559K(9728K), [Metaspace: 3029K->3029K(1056768K)], 0.0033635 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 56K->128K(2560K)] 6663K->6735K(9728K), 0.0009897 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
[Full GC (Ergonomics) [PSYoungGen: 128K->0K(2560K)] [ParOldGen: 6607K->6509K(7168K)] 6735K->6509K(9728K), [Metaspace: 3047K->3047K(1056768K)], 0.0040646 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] 6509K->6509K(9728K), 0.0006842 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] [ParOldGen: 6509K->6491K(7168K)] 6509K->6491K(9728K), [Metaspace: 3047K->3047K(1056768K)], 0.0039890 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 2560K, used 111K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 2048K, 5% used [0x00000007bfd00000,0x00000007bfd1bf38,0x00000007bff00000)
  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)
 ParOldGen       total 7168K, used 6491K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
  object space 7168K, 90% used [0x00000007bf600000,0x00000007bfc56f18,0x00000007bfd00000)
 Metaspace       used 3093K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 338K, capacity 388K, committed 512K, reserved 1048576K
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```
## 堆空间分代思想
为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99% 的对象是临时对象。

不分代完全可以，分代的唯一理由就是优化GC性能。
如果没有分代，那所有的对象都在一块，GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。比较耗费性能。
而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。


## 内存分配策略
如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。
对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代。

> PS： 对象晋升老年代的年龄阀值，可以通过选项 `-XX:MaxTenuringThreshold` 来设置

针对不同年龄段的对象分配原则:

- 优先分配到Eden。
但是开发中比较长的字符串或者数组，会直接存在老年代。因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，由于老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢

- 大对象直接分配到老年代。
尽量避免程序中出现过多的大对象

- 长期存活的对象分配到老年代。

- 动态对象年龄判断。
如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 `MaxTenuringThreshold` 中要求的年龄。

- 空间分配担保。
就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。通过`-XX:HandlePromotionFailure`参数来调节。

## TLAB

> 堆空间都是共享的么？
不是，因为还有 TLAB 这个概念，在堆中划分出一块区域，为每个线程所独占，以此来保证线程安全。

TLAB全称：`Thread Local Allocation Buffer` 译为：线程本地分配缓冲区。

因为堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，
由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。
为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。
使用锁又会影响性能，TLAB应运而生。
多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。

![TLAB](/myblog/posts/images/essays/TLAB.png)

从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden空间的百分比大小。

对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配。
尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
可以通过选项`-XX:UseTLAB`设置是否开启TLAB空间,默认是开启的。
一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

![TLAB分配过程.png](/myblog/posts/images/essays/TLAB分配过程.png)

## [JVM堆空间的参数设置](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)

- -XX：+PrintFlagsInitial：查看所有的参数的默认初始值
- -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）
- -Xms：初始堆空间内存（默认为物理内存的1/64）
- -Xmx：最大堆空间内存（默认为物理内存的1/4）
- -Xmn：设置新生代的大小。（初始值及最大值）
- -XX:NewRatio：配置新生代与老年代在堆结构的占比(默认是2)
- -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例(默认是8)
- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄（(默认是15）
- -XX:+PrintGCDetails：输出详细的GC处理日志
- -XX:+PrintGC - verbose:gc 打印gc简要信息

- -XX:HandlePromotionFailure：是否设置空间分配担保（默认true）
> 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。
  如果大于，则此次Minor GC是安全的。
  如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。
  如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
  如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
  如果小于，则改为进行一次FullGC。
  如果HandlePromotionFailure=false，则改为进行一次Full Gc。
  在JDK7之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。
JDK7之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。
>
>简而言之，在JDK7之后 -XX:HandlePromotionFailure=true 默认为true，且不会受到分配担保策略。

## 逃逸分析
> 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。
但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。
这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

还有基于openJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap:
将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。

逃逸分析是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

### 逃逸分析举例
没有发生逃逸出方法的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析

```
public static StringBuffer createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
}
```

如果想要StringBuffer sb对象不发生逃逸方法，则发生逃逸分析，可以这样写
```
public static String createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}
```

> 如何快速的判断是否发生了逃逸分析，看new的对象实体是否在方法外被调用。

## 参数设置

在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析

如果使用的是较早的版本，则可以通过：
- 选项“-XX：+DoEscapeAnalysis"显式开启逃逸分析
- 通过选项“-XX：+PrintEscapeAnalysis"查看逃逸分析的筛选结果
