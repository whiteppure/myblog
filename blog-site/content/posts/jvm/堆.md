---
title: "堆"
date: 2021-04-03
draft: false
tags: ["Java", "JVM"]
slug: "jvm-heap"
---

## 堆的核心概念
堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。
一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存的大小是可以调节的。
> -Xms10m：最小堆内存
>  
> -Xmx10m：最大堆内存

《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。

《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。
> The heap is the run-time data area from which memory for all class instances and arrays is allocated

“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。因为还有一些对象是在栈上分配的。

数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 也就是触发了GC的时候，才会进行回收
- 如果堆中对象马上被回收，那么用户线程就会收到影响，一个方法频繁的调用频繁的回收程序性能会收到影响

堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
![堆内存分配](/myblog/posts/images/essays/堆内存分配.png)

## 堆内存细分

![堆内存划分](/myblog/posts/images/essays/堆内存划分.png)

Java 7及之前**堆内存逻辑**上分为三部分：新生区+养老区+永久区

- Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Permanent Space永久区

Java 8及之后**堆内存逻辑**上分为三部分：新生区+养老区+元空间
- Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Meta Space 元空间

堆空间内部结构，JDK1.8之前从 永久代 替换成 元空间。
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8之前.png" alt="jvm1.8之前">
</div>
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8.png" alt="jvm1.8">
</div>


## 设置堆内存大小

Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项"-Xmx"和"-Xms"来进行设置。

> “-Xms"用于表示堆区的起始内存，等价于-xx:InitialHeapSize
  “-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize

*默认情况下,初始堆内存大小：物理电脑内存大小/64;最大堆内存大小：物理电脑内存大小/4*。

> 在生产环境和开发环境，通常会将-Xms和-Xmx两个参数配置相同的值，
其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

使用代码查看
```
public class MainTest {
    public static void main(String[] args) {
        // 返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        // 返回Java虚拟机试图使用的最大堆内存
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
        System.out.println("-Xms:" + initialMemory + "M");
        System.out.println("-Xmx:" + maxMemory + "M");
    }
}
```

## 查看堆内存大小

### -XX:+PrintGCDetails

程序启动加入`-XX:+PrintGCDetails`参数

![-XXPrintGCDetails](/myblog/posts/images/essays/-XXPrintGCDetails.png)

![-PrintGCDetails查看堆内存](/myblog/posts/images/essays/PrintGCDetails查看堆内存.png)


### jstat -gc

> jps  ->  jstat -gc 进程ID

![jstat](/myblog/posts/images/essays/jstat.png)

## OOM
一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出`outOfMemoryError`异常。

代码实现
```
public class MainTest {
    public static void main(String[] args) {
        ArrayList<Object> list = new ArrayList<>();
        while (true){
//            try {
//                Thread.sleep(1000000);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
            list.add(new Picture(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Picture {
    private int data;
    public Picture(int data) {
        this.data = data;
    }
}
```
![OOM](/myblog/posts/images/essays/OOM.png)


> `jvisual` 工具在 jdk /bin/jvisualvm.exe 
亦可在编译器 [下载jvisual插件](https://blog.csdn.net/qq_37960603/article/details/85224547)

出现OOM错误后，可以通过 VisualVM 这个工具查看具体是什么参数造成的
![jvisual-OOM](/myblog/posts/images/essays/jvisual-OOM.png)


## 年轻代与老年代

存储在JVM中的Java对象，按照生命周期可以被划分为两类：

一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，生命周期短的，及时回收；
另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。

Java堆区进一步细分的话，可以划分为年轻代和老年代。
其中年轻代又可以划分为Eden区、Survivor0区和 Survivor1 区（有时也叫做from区、to区）。
![年轻代与老年代](/myblog/posts/images/essays/年轻代与老年代.png)

> 没有明确规定，to 区是 Survivor1；这两个区域是不断进行交换的；是从一个区到另外一个区

测试用的代码,用于测试以下JVM参数
```
public class MainTest {
    public static void main(String[] args) {
        System.out.println("start ...");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### -XX:NewRatio

该参数是配置新生代与老年代在堆结构的占比。

默认情况下，新生代：老年代 - > 1 : 2
- 默认-XX:NewRatio=2；表示新生代占1，老年代占2，新生代占整个堆的1/3
- 可以修改-XX:NewRatio=4； 表示新生代占1，老年代占4，新生代占整个堆的1/5
![NewRatio](/myblog/posts/images/essays/NewRatio.png)

当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整年轻代与老年代的比例，来进行调优。

### -XX:SurvivorRatio
该命令是调整eden区与survivor区比例。这个参数一般使用默认值就可以了。

在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，
当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如：-XX:SurvivorRatio=8。

> PS 在实际开发中使用hotspot虚拟机，默认情况下不是8：1：1；
是因为虚拟机有一个自适应内存分配策略，可以通过`-XX:-UseAdaptiveSizePolicy`关闭再来进行查看.
![SurvivorRatio](/myblog/posts/images/essays/SurvivorRatio.png)

几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）

IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。

可以使用选项"-Xmn"设置新生代最大内存大小。
> PS 当 -Xmn 参数与 -XX:NewRatio 设置的值发生冲突时，会以 -Xmn 设置的具体值为准。

![eden与survivor与tenured](/myblog/posts/images/essays/eden与survivor与tenured.png)

## 为对象分配内存
为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，
并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

对象分配内存步骤：
![对象内存分配策略](/myblog/posts/images/essays/对象内存分配策略.png)

1. 新的对象先放伊甸园区。此区有大小限制。(如果对象过大可能直接分配在老年代)
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行MinorGC，将伊甸园区中的不再被其他对象所引用的对象进行销毁。
再将新的对象放到伊甸园区。
3. 然后将伊甸园中的剩余对象移动到幸存者0区。
4. 如果再次触发MinorGC，会首先将没有被回收的对象放到幸存者1区，然后判断幸存者0区中的对象是否能被回收，如果没有回收，就会放到幸存者1区。
5. 重复步骤3、4，默认情况下如果一个对象被扫描了15次（阈值），都不能被回收，则将该对象晋升到老年代。
6. 当老年代内存不足时，再次触发GC：Major GC，进行老年代的内存清理。
7. 若老年代执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM错误。

*可以用 -XX:MaxTenuringThreshold=N  进行设置幸存者区到老年代的GC扫描次数，默认15次。*


> PS 如果幸存者区满了？
如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。
**需要特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作**

代码演示对象分配过程
```
// -Xms600m -Xmx600m
public class HeapInstanceTest {
    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];
    public static void main(String[] args) throws InterruptedException {
        ArrayList<HeapInstanceTest> list = new ArrayList<>();
        while (true) {
            list.add(new HeapInstanceTest());
            Thread.sleep(10);
        }
    }
}
```
打开`VisualVM`图形化界面,通过`VisualGC`进行动态化查看
![代码演示对象分配过程](/myblog/posts/images/essays/代码演示对象分配过程.gif)

> 总结： 
>- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to区
>- 关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集
>- 新生代采用复制算法的目的：是为了减少内碎片

