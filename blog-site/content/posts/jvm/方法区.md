---
title: "方法区"
date: 2021-04-08
draft: false
tags: ["Java", "JVM"]
slug: "jvm-method-area"
---
Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。
另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

![运行时数据区](/myblog/posts/images/essays/运行时数据区.png)

运行时数据区域包括

- 程序计数寄存器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

其中：方法区、堆为线程共享；程序计数寄存器、虚拟机栈、本地方法栈 为线程私有。

## 方法区

### 对于方法区的理解
> 尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。
”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。

方法区看作是一块独立于Java堆的内存空间。下图说明了栈、堆、方法区的交互关系
![方法区定位](/myblog/posts/images/essays/方法区定位.png)

- 方法区主要存放的是 class，而堆中主要存放的是实例化的对象.
- 方法区与Java堆一样，是各个线程共享的内存区域。
- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，
虚拟机同样会抛出内存溢出错误：`java.lang.OuOfMemoryError：PermGen space` 或者`java.lang.OutOfMemoryError:Metaspace`
- 关闭JVM就会释放这个区域的内存。

### HotSpot中JDK7与JDK8
在JDK7及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。
JDK 1.8后，元空间存放在直接内存中。
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8之前.png" alt="jvm1.8之前">
</div>
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8.png" alt="jvm1.8">
</div>

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。

永久代、元空间二者并不只是名字变了，内部结构也调整了。
根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。

### 设置方法区大小
方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。

#### JDK7及之前
通过参数`-XX:Permsize=size`来设置永久代初始分配空间。默认值是20.75M
通过参数`-XX:MaxPermsize=size`来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M
当JVM加载的类信息容量超过了这个值，会报异常`OuOfMemoryError:PermGen space`。

#### JDK8及之后
元空间大小可以使用参数 `-XX:MetaspaceSize=size` 和 `-XX:MaxMetaspaceSize=size` 来指定。

默认值依赖于平台。windows下，`-XX:MetaspaceSize`是21M，`-XX:MaxMetaspaceSize`的值是-1，由于直接存放在直接内存中所以没有限制。

与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。
如果元数据区发生溢出，虚拟机一样会抛出异常`OutOfMemoryError:Metaspace`。

`-XX:MetaspaceSize=size`设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的`-XX:MetaspaceSize`值为21MB。
这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类即这些类对应的类加载器不再存活然后这个高水位线将会重置。
新的高水位线的值取决于GC后释放了多少元空间。
如果释放的空间不足，那么在不超过`MaxMetaspaceSize`时，适当提高该值。如果释放空间过多，则适当降低该值。

如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。
通过垃圾回收器的日志可以观察到Ful1GC多次调用。
**为了避免频繁地GC，建议将`-XX:MetaspaceSize=size`设置为一个相对较高的值。**

### OOM

要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，
重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）.

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。
于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。
掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。

如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），
与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。




