---
title: "垃圾回收"
date: 2021-04-21
draft: false
tags: ["Java", "JVM"]
slug: "java-garbage-collection"
---

## 垃圾回收
垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。

垃圾收集机制是Java的招牌能力，极大地提高了开发效率。
如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。

### 什么是垃圾
> 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致**内存溢出**。

### 为什么需要垃圾回收
对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。

除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。

随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。

### 早期垃圾回收
在早期的C/C++时代，垃圾回收基本上是手工进行的。
开发人员可以使用 `new` 关键字进行内存申请，并使用 `delete` 关键字进行内存释放。比如以下代码：
```
MibBridge *pBridge= new cmBaseGroupBridge();
//如果注册失败，使用Delete释放该对象所占内存区域
if(pBridge->Register (kDestroy) != NO ERROR）
	delete pBridge;
```
这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。

倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生**内存泄漏**;
垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。

有了垃圾回收机制后，上述代码极有可能变成这样
```
MibBridge *pBridge=new cmBaseGroupBridge(); 
pBridge->Register(kDestroy);
```
现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。

### [Java垃圾回收机制](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)
自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低**内存泄漏**和**内存溢出**的风险;
没有垃圾回收器，java也会和c++一样，各种悬垂指针，野指针，泄露问题让你头疼不已。

自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发.

对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。

此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见`outOfMemoryError`时，快速地根据错误异常日志定位问题和解决问题。

当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。

### 垃圾回收主要关注的区域
垃圾收集器主要对 方法区 、堆中的垃圾收集
![GC作用区域](/myblog/posts/images/essays/GC作用区域.png)

垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收；
其中，Java堆是垃圾收集器的工作重点。

从次数上讲：频繁收集新生代 > 较少收集老年代 >> 基本不收集方法区

## 垃圾回收相关算法

### 标记阶段
在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。
只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为**垃圾标记阶段**。

在运行程序中，当一个对象已经不再被任何存活的对象引用时，就可以就可以判定该对象已经死亡了；
判定对象是否存活在有两种算法，应用技术算法、可达性分析算法。

#### 引用计数算法
对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
在堆中判定新生代中的幸存者区是否可以进老年代，会有一个年龄计数器，这里用的就是引用计数算法。

- 优点：实现简单，垃圾对象便于辨识；判定效率高，回收垃圾没有延迟性。

缺点：
- 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
- 无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

**循环引用**

当p的指针断开的时候，内部的引用形成一个循环，从而造成内存泄漏。

![循环引用](/myblog/posts/images/essays/循环引用.png)

Java并没有选择引用计数算法，是因为其存在一个基本的难题，也就是很难处理循环引用关系。
虽然引用计数算法存在循环引用的问题，但是很多语言的资源回收选择，例如：因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制；
具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。

**Python如何解决循环引用？**
- 手动解除：很好理解，就是在合适的时机，将引用计数器中的计数属性置为零，解除引用关系。 
- 使用弱引用`weakref`，`weakref`是Python提供的标准库，旨在解决循环引用。

#### 可达性分析算法
可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
所谓根集合"GCRoots”就是一组必须活跃的引用，即有在栈中有指针指向堆中的地址；
可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集。

相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。

在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象；
使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链；
如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
![可达性分析算法](/myblog/posts/images/essays/可达性分析算法.png)

**对象集合（GC Roots）可以是哪些？**

 1. 虚拟机栈中引用的对象；例如：各个线程被调用的方法中使用到的参数、局部变量等
 2. 本地方法栈内,本地方法引用对象方法区中类静态属性引用的对象;例如：Java类的引用类型静态变量
 3. 方法区中常量引用的对象；例如：字符串常量池里的引用
 4. 所有被同步锁`synchronized`持有的对象；例如：
 5. Java虚拟机内部的引用；例如：一些常驻的异常对象、系统类加载器等
 6. 反映java虚拟机内部情况的`JMXBean、JVMTI`中注册的回调、本地代码缓存等
 7. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合;比如：分代收集和局部回收

除了堆空间产生对象的一些结构外，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间的对象的引用，都可以作为GC Roots进行可达性分析。
![对象集合GCroots](/myblog/posts/images/essays/对象集合GCroots.png)

> 如何判定是否为`GC root`?
由于Root采用栈方式存放变量和指针，所以如果一个指针，保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root

**使用注意**

如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
简单来说就是执行这个算法的时候，要停止程序标记对象，不能一边改变对象的引用一边判定对象是不是垃圾。

这点也是导致GC进行时必须`stop The World`的一个重要原因。即使是号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。


### 对象的终止机制
Java语言提供了对象终止（`finalization`）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的`finalize()`方法。

`finalize()` 方法允许在子类中被重写，用于在对象被回收时进行资源释放。
通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。

文档注释大意：当GC确定不再有对对象的引用时，由垃圾收集器在对象上调用。子类重写`finalize`方法来释放系统资源或执行其他清理。
```
   /**
     * Called by the garbage collector on an object when garbage collection
     * determines that there are no more references to the object.
     * A subclass overrides the {@code finalize} method to dispose of
     * system resources or to perform other cleanup.
     */
    protected void finalize() throws Throwable { }
```

**永远不要主动调用某个对象的`finalize`方法应该交给垃圾回收机制调用原因**

- 在调用`finalize`方法时时可能会导致对象复活；
- `finalize`方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则`finalize`方法将没有执行机会;
因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收
- 一个糟糕的`finalize`方法会严重影响GC的性能;

**由于`finalize`方法的存在,虚拟机中的对象一般处于三种可能的状态**

如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。
但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，虚拟机中定义了的对象可能的三种状态：
- 可触及的：从根节点开始，可以到达这个对象；对象存活被使用；
- 可复活的：对象的所有引用都被释放，但是对象有可能在`finalize`中复活；对象被复活，对象在`finalize`方法中被重新使用；
- 不可触及的：对象的`finalize`方法被调用，并且没有复活，那么就会进入不可触及状态；对象死亡，对象没有被使用；

只有在对象不可触及时才可以被回收。不可触及的对象不可能被复活，因为`finalize()`只会被调用一次。

**`finalize`机制判定一个对象能否被回收过程**

判定一个对象是否可回收，至少要经历两次标记过程：
- 如果对象没有没有引用链，则进行第一次标记
- 进行筛选，判断此对象是否有必要执行`finalize`方法
    1. 如果对象没有重写`finalize`方法，或者`finalize`方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，对象被判定为不可触及的。
    2. 如果对象重写了`finalize`方法，且还未执行过，那么会被插入到`F-Queue`队列中，由一个虚拟机自动创建的、低优先级的`Finalizer`线程触发其`finalize`方法执行。
    3. `finalize`方法是对象逃脱死亡的最后机会，稍后GC会对`F-Queue`队列中的对象进行第二次标记。如果对象在`finalize`方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，该对象会被移出“即将回收”集合。
    之后，对象会再次出现没有引用存在的情况。在这个情况下，`finalize`方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的`finalize`方法只会被调用一次。
    
代码演示对象能否被回收过程
```
public class MainTest {

    public static MainTest var;

    /**
     * 此方法只能被调用一次
     * 可对该方法进行注释，来测试finalize方法是否能复活对象
     */
    @Override
    protected void finalize() throws Throwable {
        System.out.println("调用当前类重写的finalize()方法");
        // 复活对象 让当前带回收对象重新与引用链中的对象建立联系
        var = this;
    }

    public static void main(String[] args) throws InterruptedException {
        var = new MainTest();
        var = null;
        System.gc();
        System.out.println("-----------------第一次gc操作------------");
        // 因为Finalizer线程的优先级比较低，暂停2秒，以等待它
        Thread.sleep(2000);
        if (var == null) {
            System.out.println("对象已经死了");
            // 如果第一次对象就死亡了 就终止
            return;
        } else {
            System.out.println("对象还活着");
        }

        System.out.println("-----------------第二次gc操作------------");
        var = null;
        System.gc();
        // 下面代码和上面代码是一样的，但是 对象却自救失败了
        Thread.sleep(2000);
        if (var == null) {
            System.out.println("对象已经死了");
        } else {
            System.out.println("对象还活着");
        }
    }

}
```