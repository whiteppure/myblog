---
title: "运行时数据区"
date: 2021-03-27
draft: false
tags: ["Java", "JVM"]
slug: "jvm-runtime"
---


Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。
另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

![运行时数据区](/myblog/posts/images/essays/运行时数据区.png)

运行时数据区域包括

- 程序计数寄存器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

其中：方法区、堆为线程共享；程序计数寄存器、虚拟机栈、本地方法栈 为线程私有。

## 程序计数寄存器

### 概述
JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。
CPU只有把数据装载到寄存器才能够运行。
这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

**特点**
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
- 它是唯一一个在Java虚拟机规范中没有规定任何`outOfMemoryError`情况的区域。

程序计数器中既不存在GC又不存在OOM，所以不存在垃圾回收问题。

**作用**
- PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

由于Java的多线程是通过线程轮流切换完成的，一个线程没有执行完时就需要一个东西记录它执行到哪了，下次抢占到了CPU资源时再从这开始，
这个东西就是程序计数器，正是因为这样，所以它也是“线程私有”的内存。

**代码演示**
```
public class MainTest {
    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int k = i + j;

        String str = "abc";
        System.out.println(str);
        System.out.println(k);
    }
}

```
通过`javap -verbose MainTest.class`命令反编译`.class`文件，得到如下
```
// ...
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=5, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        20
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: ldc           #2                  // String abc
        12: astore        4
        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        17: aload         4
        19: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        22: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        25: iload_3
        26: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
        29: return
// ...

```
通过PC寄存器，我们就可以知道当前程序执行到哪一步了。
![PC寄存器保存指令示意](/myblog/posts/images/essays/PC寄存器保存指令示意.png)

### 常见问题

***使用PC寄存器存储字节码指令地址有什么用呢？***

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

***PC寄存器为什么被设定为私有的？***

我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，
如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，
这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

## 虚拟机栈

### 介绍
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，
其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。

#### 生命周期

生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了

#### 作用

主管Java程序的运行，它保存方法的局部变量（8中基本数据类型及对象的引用地址）、部分结果，并参与方法的调用和返回。

#### 栈的特点

栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个
- 每个方法执行，伴随着进栈（入栈、压栈）
- 执行结束后的出栈工作

对于栈来说不存在垃圾回收问题（栈存在溢出的情况：OOM异常）

> PS 栈与堆
> 1.首先栈是运行时的单位，而堆是存储的单位
  2.栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里

与程序计数器一样，Java的虚拟机栈也是线程私有的，虚拟机栈描述的是Java的方法执行的内存模型，
方法每个执行在同时的创建都会一个栈桢用于存储局部变量表，操作数栈，动态链接，方法出口等信息。

#### 栈的异常

Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。

如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。
如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个`StackOverflowError`异常。
```
public class MainTest {
    private static int count = 1;
    public static void main(String[] args) {
        System.out.println(count++);
        main(args);
    }
}
```
抛出异常栈内存不足
```
// ...
9377*** 
Exception in thread "main" java.lang.StackOverflowError
// ...
```

在使用递归的情况下，如果线程请求的栈的深度超过虚拟机所允许栈的深度就会抛出`StackOverflowError`；
但是大部分虚拟机栈的深度都可以动态扩展，HotSpot中使用 Xss 可以设置栈的深度，如果扩展时无法请求到足够的内存就会抛出`OutOfMemoryError`。

可以设置栈的内存大小，使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。
```
-Xss256m
-Xss256k
```

### 栈的存储结构

#### 栈的存储单位

- 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
- 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

#### 栈中存储内容

每个线程都有自己的栈，栈中的数据都是以**栈帧**(Stack Frame)的格式存在。
在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。
栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”或“后进先出”原则。

在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，
这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。

执行引擎运行的所有字节码指令只针对当前栈帧进行操作。

如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
![栈中存储内容](/myblog/posts/images/essays/栈中存储内容.png)

代码演示
```
public class MainTest {

    public static void main(String[] args) {
        method01();
    }

    private static int method01() {
        System.out.println("方法1的开始");
        int i = method02();
        System.out.println("方法1的结束");
        return i;
    }

    private static int method02() {
        System.out.println("方法2的开始");
        int i = method03();;
        System.out.println("方法2的结束");
        return i;
    }
    private static int method03() {
        System.out.println("方法3的开始");
        int i = 30;
        System.out.println("方法3的结束");
        return i;
    }

}
```

#### 栈的运行原理

不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。

Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

#### 栈帧的结构

每个栈帧中存储着：
- 局部变量表
- 操作数栈（或表达式栈）
- 动态链接（或指向运行时常量池的方法引用）
- 方法返回地址（或方法正常退出或者异常退出的定义）
- 一些附加信息

![栈桢的结构](/myblog/posts/images/essays/栈桢的结构.png)

每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由 局部变量表 和 操作数栈 决定的。

### 栈桢

#### 局部变量表

局部变量表：Local Variables，被称之为局部变量数组或本地变量表。

定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。

由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。

*局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的`maximum local variables`数据项中。
在方法运行期间是不会改变局部变量表的大小的。*

![字节码介绍](/myblog/posts/images/essays/字节码介绍.png)
![局部变量表](/myblog/posts/images/essays/局部变量表.png)

方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。
对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。
进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。

局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。


##### Slot
局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。

参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1的索引结束。

在局部变量表里，32位以内的类型只占用一个slot，64位的类型（1ong和double）占用两个slot。

byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 1ong和double则占据两个slot。
JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值

当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上

如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）

如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。

![slot](/myblog/posts/images/essays/slot.png)

##### Slot重复利用
栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，
从而达到节省资源的目的。

代码演示
```
    public void test() {
        int a = 0;
        {
            int b = 0;
            b = a + 1;
        }
        int c = a + 1;
    }

```
![slot重复利用](/myblog/posts/images/essays/slot重复利用.png)

##### 静态变量与局部变量
变量的分类：

- 按数据类型分：基本数据类型、引用数据类型
- 按类中声明的位置分：成员变量（类变量，实例变量）、局部变量
    - 类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块
    - 实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值
    - 局部变量：在使用前必须进行显式赋值，不然编译不通过。

参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。

我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

*在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。*

#### 操作数栈

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的 操作数栈，也可以称之为 表达式栈。
> PS: 栈为抽象数据结构，不是真实存在的。一般可以用数组或者链表来实现。这里是假定是用数组实现栈结构。

操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）。

- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。
- 比如：执行复制、交换、求和等操作。
![操作数栈add](/myblog/posts/images/essays/操作数栈add.png)

举例

![操作数栈代码举例](/myblog/posts/images/essays/操作数栈代码举例.png)

操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
> PS：这个时候操作数栈是有长度的，数组一旦创建，那么就是不可变的

操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。

每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为`maxstack`的值。

栈中的任何一个元素都可以是任意的Java数据类型
- 32bit的类型占用一个栈单位深度
- 64bit的类型占用两个栈单位深度

操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问；
如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。
另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。

#### 动态链接
每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。
比如：invokedynamic指令。

![动态链接](/myblog/posts/images/essays/动态链接.png)
![常量池](/myblog/posts/images/essays/常量池.png)

在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。
比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，
那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

> 为什么需要运行时常量池？
> 
>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间。常量池的作用：就是为了提供一些符号和常量，便于指令的识别

#### 方法返回值

### 栈顶缓存技术

基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，
这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。
为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，
将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。

> 寄存器：指令更少，执行速度快

### 方法的调用
在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

#### 链接
**静态链接**

当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期克制，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接

**动态链接**

如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。


#### 绑定机制
对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。
绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

**早期绑定**

早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

**晚期绑定**

如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。

#### 虚方法和非虚方法
Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法

- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。



## 本地方法栈

## 堆

## 方法区

