<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>Java语法糖 ｜ whitepure</title>
	
    
    
    <meta name="description" content="" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	
    
    <link rel="shortcut icon" href="https://whiteppure.github.io/myblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div class="toc">

    <div class="page-header"><strong>- CATALOG -</strong></div>

    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%af%ad%e6%b3%95%e7%b3%96">
                    语法糖
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%a7%a3%e8%af%ad%e6%b3%95%e7%b3%96">
                    解语法糖
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#switch-%e6%94%af%e6%8c%81-string-%e4%b8%8e%e6%9e%9a%e4%b8%be">
                    switch 支持 String 与枚举
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b3%9b%e5%9e%8b">
                    泛型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e8%a3%85%e7%ae%b1%e4%b8%8e%e6%8b%86%e7%ae%b1">
                    自动装箱与拆箱
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%96%b9%e6%b3%95%e5%8f%98%e9%95%bf%e5%8f%82%e6%95%b0">
                    方法变长参数
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%9e%9a%e4%b8%be">
                    枚举
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%86%85%e9%83%a8%e7%b1%bb">
                    内部类
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%96%ad%e8%a8%80">
                    断言
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e5%80%bc%e5%ad%97%e9%9d%a2%e9%87%8f">
                    数值字面量
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#for-each">
                    for-each
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#try-with-resource">
                    try-with-resource
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#lambda%e8%a1%a8%e8%be%be%e5%bc%8f">
                    Lambda表达式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%af%e8%83%bd%e9%81%87%e5%88%b0%e7%9a%84%e5%9d%91">
                    可能遇到的坑
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b3%9b%e5%9e%8b%e5%bd%93%e6%b3%9b%e5%9e%8b%e9%81%87%e5%88%b0%e9%87%8d%e8%bd%bd">
                    泛型——当泛型遇到重载
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b3%9b%e5%9e%8b%e5%bd%93%e6%b3%9b%e5%9e%8b%e9%81%87%e5%88%b0catch">
                    泛型——当泛型遇到catch
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e8%a3%85%e7%ae%b1%e4%b8%8e%e6%8b%86%e7%ae%b1%e5%af%b9%e8%b1%a1%e7%9b%b8%e7%ad%89%e6%af%94%e8%be%83">
                    自动装箱与拆箱——对象相等比较
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a2%9e%e5%bc%bafor%e5%be%aa%e7%8e%af">
                    增强for循环
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%80%bb%e7%bb%93">
                    总结
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    
    <div class="main animate__animated animate__fadeInDown" id="pdf_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/myblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/myblog/" style="width: 100%">
                    <span>whitepure</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">大道至简</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/whiteppure/" title="github" target="_blank">
                    <i class="ri-github-fill"></i>
                </a>
                
                
                <a href="https://whiteppure.github.io/myblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                <button id="export_pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 4px">
                    <svg t="1614337230032" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2940" width="10" height="10"><path d="M825.202759 488.292634L584.527448 244.926676v484.916965c0 40.197297-32.584386 72.774621-72.781682 72.774621-40.190234 0-72.767559-32.577324-72.767559-72.774621V245.654069L197.999228 490.404193c-27.68331 28.29771-73.071228 28.784993-101.368938 1.094621a74.526014 74.526014 0 0 1-1.094621-105.168331L454.182841 22.076028a70.182841 70.182841 0 0 1 63.8976-19.067587 70.8608 70.8608 0 0 1 52.111007 21.179145l356.973462 360.977655c28.156469 28.608441 28.156469 74.518952 0 103.127393-27.662124 28.156469-72.915862 28.559007-101.065269 0.896883a53.699972 53.699972 0 0 1-0.896882-0.896883m123.211917 532.663614H75.083917c-40.190234 0-72.774621-32.584386-72.77462-72.781682v-145.556304c0-40.197297 32.59851-72.767559 72.788744-72.760496 40.183172 0.007062 72.753434 32.577324 72.767559 72.760496v72.774621h727.774455v-72.774621c0-40.197297 32.584386-72.774621 72.774621-72.774621 40.197297 0 72.774621 32.577324 72.774621 72.774621v145.556304c0 40.197297-32.577324 72.781683-72.774621 72.781682" fill="#707070" p-id="2941"></path></svg>
                </button>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/myblog/posts/essays/java-syntax-sugar/'>Java语法糖</a></h2>
                        <span class="date">2021.04.10</span>
                    </div>
                    <div class="post_content markdown"><p>原文地址：<a href="https://www.jianshu.com/p/0f967298a5d7">https://www.jianshu.com/p/0f967298a5d7</a></p>
<h2 id="语法糖">语法糖</h2>
<p>语法糖（<code>Syntactic Sugar</code>），也称糖衣语法，是由英国计算机学家 <code>Peter.J.Landin</code> 发明的一个术语，指在计算机语言中添加的某种语法，
这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p>
<blockquote>
<p>在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。
我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。</p>
</blockquote>
<p>很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，
主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。</p>
<h3 id="解语法糖">解语法糖</h3>
<p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p>
<p>说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。</p>
<p>如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>
<h4 id="switch-支持-string-与枚举">switch 支持 String 与枚举</h4>
<p>前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中switch开始支持String。</p>
<p>在开始coding之前先科普下，Java中的swith自身原本就支持基本类型。比如int、char等。</p>
<p>对于int类型，直接进行数值的比较。对于char类型则是比较其ascii码。</p>
<p>所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte。short，char</code>(ackii码是整型)以及int。</p>
<p>那么接下来看下switch对String得支持，有以下代码：</p>
<pre><code>public class switchDemoString {
    public static void main(String[] args) {
        String str = &quot;world&quot;;
        switch (str) {
            case &quot;hello&quot;:
                        System.out.println(&quot;hello&quot;);
            break;
            case &quot;world&quot;:
                        System.out.println(&quot;world&quot;);
            break;
            default:
                        break;
        }
    }
}
</code></pre><p>反编译后内容如下：</p>
<pre><code>public class switchDemoString
{
    public switchDemoString()
        {
    }
    public static void main(String args[])
        {
        String str = &quot;world&quot;;
        String s;
        switch((s = str).hashCode())
                {
            default:
                        break;
            case 99162322:
                        if(s.equals(&quot;hello&quot;))
                            System.out.println(&quot;hello&quot;);
            break;
            case 113318802:
                        if(s.equals(&quot;world&quot;))
                            System.out.println(&quot;world&quot;);
            break;
        }
    }
}
</code></pre><p>看到这个代码，你知道原来字符串的switch是通过equals()和hashCode()方法来实现的。还好hashCode()方法返回的是int，而不是long。</p>
<blockquote>
<p>仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，
因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。</p>
</blockquote>
<h4 id="泛型">泛型</h4>
<p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的。</p>
<p>通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。</p>
<p>C++和C#是使用<code>Code specialization</code>的处理机制，而Java使用的是<code>Code sharing</code>的机制。</p>
<blockquote>
<p>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。
也就是说，对于Java虚拟机来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p>
</blockquote>
<p>类型擦除的主要过程如下：</p>
<ul>
<li>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</li>
<li>移除所有的类型参数。</li>
</ul>
<p>以下代码：</p>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  
map.put(&quot;name&quot;, &quot;suxiansheng&quot;);  
map.put(&quot;wechat&quot;, &quot;java&quot;);  
map.put(&quot;blog&quot;, &quot;https://www.jianshu.com/u/94111742c97c&quot;);  
</code></pre><p>解语法糖之后会变成：</p>
<pre><code>Map map = new HashMap();  
map.put(&quot;name&quot;, &quot;suxiansheng&quot;);  
map.put(&quot;wechat&quot;, &quot;Java&quot;);  
map.put(&quot;blog&quot;, &quot;https://www.jianshu.com/u/94111742c97c&quot;);  
</code></pre><p>以下代码：</p>
<pre><code>public static &lt;A extends Comparable&lt;A&gt;&gt; A max(Collection&lt;A&gt; xs) {
    Iterator&lt;A&gt; xi = xs.iterator();
    A w = xi.next();
    while (xi.hasNext()) {
        A x = xi.next();
        if (w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}
</code></pre><p>类型擦除后会变成：</p>
<pre><code> public static Comparable max(Collection xs){
    Iterator xi = xs.iterator();
    Comparable w = (Comparable)xi.next();
    while(xi.hasNext())
    {
        Comparable x = (Comparable)xi.next();
        if(w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}
</code></pre><p>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。
比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</p>
<h4 id="自动装箱与拆箱">自动装箱与拆箱</h4>
<p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。参考：一文读懂什么是Java中的自动拆装箱</p>
<p>因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p>
<p>原始类型<code>byte, short, char, int, long, float, double，boolean</code> 对应的封装类为<code>Byte, Short, Character, Integer, Long, Float, Double, Boolean</code>。</p>
<p>先来看个自动装箱的代码：</p>
<pre><code> public static void main(String[] args) {
    int i = 10;
    Integer n = i;
}
</code></pre><p>反编译后代码如下:</p>
<pre><code>public static void main(String args[])
{
    int i = 10;
    Integer n = Integer.valueOf(i);
}
</code></pre><p>再来看个自动拆箱的代码：</p>
<pre><code>public static void main(String[] args) {

    Integer i = 10;
    int n = i;
}
</code></pre><p>反编译后代码如下：</p>
<pre><code>public static void main(String args[])
{
    Integer i = Integer.valueOf(10);
    int n = i.intValue();
}
</code></pre><p>从反编译得到内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。
而在拆箱的时候自动调用的是Integer的intValue方法。
所以，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。</p>
<h4 id="方法变长参数">方法变长参数</h4>
<p>可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>
<p>看下以下可变参数代码，其中print方法接收可变参数：</p>
<pre><code>public static void main(String[] args)
    {
        print(&quot;java&quot;, &quot;123&quot;, &quot;456&quot;, &quot;789&quot;);
    }

public static void print(String... strs)
{
    for (int i = 0; i &lt; strs.length; i++)
    {
        System.out.println(strs[i]);
    }
}
</code></pre><p>反编译后代码：</p>
<pre><code>public static void main(String args[])
{
    print(new String[] {
        &quot;java&quot;, &quot;123&quot;, &quot;456&quot;, &quot;789&quot;
    });
}

public static transient void print(String strs[])
{
    for(int i = 0; i &lt; strs.length; i++)
        System.out.println(strs[i]);

}
</code></pre><p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，
然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>
<h4 id="枚举">枚举</h4>
<p>Java SE5提供了一种新的类型-Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>
<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？</p>
<p>答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类。</p>
<p>那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>
<pre><code>public enum t {
    SPRING,SUMMER;
}
</code></pre><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>
<pre><code>public final class T extends Enum
{
    private T(String s, int i)
    {
        super(s, i);
    }
    public static T[] values()
    {
        T at[];
        int i;
        T at1[];
        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
        return at1;
    }

    public static T valueOf(String s)
    {
        return (T)Enum.valueOf(demo/T, s);
    }

    public static final T SPRING;
    public static final T SUMMER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T(&quot;SPRING&quot;, 0);
        SUMMER = new T(&quot;SUMMER&quot;, 1);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER
        });
    }
}
</code></pre><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，
该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。</p>
<p>当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</p>
<h4 id="内部类">内部类</h4>
<p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>
<p>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p>
<p><code>outer.java</code>里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件了，
分别是<code>outer.class</code>和<code>outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</p>
<pre><code>public class OutterClass {
    private String userName;

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public static void main(String[] args) {

    }

    class InnerClass{
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}
</code></pre><p>以上代码编译后会生成两个class文件：<code>OutterClass$InnerClass.class 、OutterClass.class</code> 。</p>
<p>当我们尝试使用jad对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：</p>
<pre><code>Parsing OutterClass.class...
Parsing inner class OutterClass$InnerClass.class...
Generating OutterClass.jad
</code></pre><p>他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>
<pre><code>public class OutterClass
{
    class InnerClass
    {
        public String getName()
        {
            return name;
        }
        public void setName(String name)
        {
            this.name = name;
        }
        private String name;
        final OutterClass this$0;

        InnerClass()
        {
            this.this$0 = OutterClass.this;
            super();
        }
    }

    public OutterClass()
    {
    }
    public String getUserName()
    {
        return userName;
    }
    public void setUserName(String userName){
        this.userName = userName;
    }
    public static void main(String args1[])
    {
    }
    private String userName;
}
</code></pre><p>七 、条件编译</p>
<p>—般情况下，程序中的每一行代码都要参加编译。
但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>
<p>如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：</p>
<pre><code>public class ConditionalCompilation {
    public static void main(String[] args) {
        final boolean DEBUG = true;
        if(DEBUG) {
            System.out.println(&quot;Java, DEBUG!&quot;);
        }

        final boolean ONLINE = false;

        if(ONLINE){
            System.out.println(&quot;Java, ONLINE!&quot;);
        }
    }
}
</code></pre><p>反编译后代码如下：</p>
<pre><code>public class ConditionalCompilation
{

    public ConditionalCompilation()
    {
    }

    public static void main(String args[])
    {
        boolean DEBUG = true;
        System.out.println(&quot;Java, DEBUG!&quot;);
        boolean ONLINE = false;
    }
}
</code></pre><p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(&quot;Hello, ONLINE!&quot;);</code>，这其实就是条件编译。</p>
<p>当if(ONLINE)为false的时候，编译器就没有对其内的代码进行编译。
所以，Java语法的条件编译，是通过判断条件为常量的if语句实现的。根据if判断条件的真假，编译器直接把分支为false的代码块消除。
通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。</p>
<p>这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</p>
<h4 id="断言">断言</h4>
<p>在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，
Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。</p>
<p>如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>
<p>看一段包含断言的代码：</p>
<pre><code>public class AssertTest {
    public static void main(String args[]) {
        int a = 1;
        int b = 1;
        assert a == b;
        System.out.println(&quot;Java&quot;);
        assert a != b : &quot;suxiansheng&quot;;
        System.out.println(&quot;博客：https://www.jianshu.com/u/94111742c97c&quot;);
    }
}
</code></pre><p>反编译后代码如下：</p>
<pre><code>public class AssertTest {
   public AssertTest()
    {
    }
    public static void main(String args[])
{
    int a = 1;
    int b = 1;
    if(!$assertionsDisabled &amp;&amp; a != b)
        throw new AssertionError();
    System.out.println(&quot;\u516C\u4F17\u53F7\uFF1AJava&quot;);
    if(!$assertionsDisabled &amp;&amp; a == b)
    {
        throw new AssertionError(&quot;Java&quot;);
    } else
    {
        System.out.println(&quot;\u535A\u5BA2\uFF1Awww.jianshu.com/u/94111742c97c&quot;);
        return;
    }
}

static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();

}
</code></pre><p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。</p>
<p>其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。</p>
<h4 id="数值字面量">数值字面量</h4>
<p>在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>
<p>比如：</p>
<pre><code>public class Test {
    public static void main(String... args) {
        int i = 10_000;
        System.out.println(i);
    }
}
</code></pre><p>反编译后：</p>
<pre><code>public class Test
{
  public static void main(String[] args)
  {
    int i = 10000;
    System.out.println(i);
  }
}
</code></pre><p>反编译后就是把删除了。也就是说<strong>编译器并不认识在数字字面量中的，需要在编译阶段把他去掉</strong>。</p>
<h4 id="for-each">for-each</h4>
<p>增强for循环（for-each）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？</p>
<pre><code>public static void main(String... args) {
    String[] strs = {&quot;suxiansehng&quot;, &quot;Java&quot;, &quot;博客：www.jianshu.com/u/94111742c97c&quot;};
    for (String s : strs) {
        System.out.println(s);
    }
    List&lt;String&gt; strList = ImmutableList.of(&quot;suxiansheng&quot;, &quot;java&quot;, &quot;博客：www.jianshu.com/u/94111742c97c&quot;);
    for (String s : strList) {
        System.out.println(s);
    }
}
</code></pre><p>反编译后代码如下：</p>
<pre><code>public static transient void main(String args[])
{
    String strs[] = {
        &quot;suxiansheng&quot;, &quot;\u516C\u4F17\u53F7\uFF1AJava&quot;, &quot;\u535A\u5BA2\uFF1Awww.jianshu.com/u/94111742c97c&quot;
    };
    String args1[] = strs;
    int i = args1.length;
    for(int j = 0; j &lt; i; j++)
    {
        String s = args1[j];
        System.out.println(s);
    }

    List strList = ImmutableList.of(&quot;suxiansheng&quot;, &quot;\u516C\u4F17\u53F7\uFF1AJava&quot;, &quot;\u535A\u5BA2\uFF1Awww.jianshu.com/u/94111742c97c&quot;);
    String s;
    for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))
        s = (String)iterator.next();

}
</code></pre><p>代码很简单，for-each的实现原理其实就是使用了普通的for循环和迭代器。</p>
<h4 id="try-with-resource">try-with-resource</h4>
<p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>
<p>关闭资源的常用方式就是在finally块里是释放，即调用close方法。比如，我们经常会写这样的代码：</p>
<pre><code>public static void main(String[] args) {
    BufferedReader br = null;
    try {
        String line;
        br = new BufferedReader(new FileReader(&quot;d:\\hollischuang.xml&quot;));
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    } finally {
        try {
            if (br != null) {
                br.close();
            }
        } catch (IOException ex) {
            // handle exception
        }
    }
}
</code></pre><p>从Java 7开始，jdk提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>
<pre><code>public static void main(String... args) {
    try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;))) {
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    }
}
</code></pre><p>看，这简直是一大福音啊，虽然我之前一般使用IOUtils去关闭流，并不会使用在finally中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。</p>
<p>反编译以上代码，看下他的背后原理：</p>
<pre><code>public static transient void main(String args[])
    {
        BufferedReader br;
        Throwable throwable;
        br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;));
        throwable = null;
        String line;
        try
        {
            while((line = br.readLine()) != null)
                System.out.println(line);
        }
        catch(Throwable throwable2)
        {
            throwable = throwable2;
            throw throwable2;
        }
        if(br != null)
            if(throwable != null)
                try
                {
                    br.close();
                }
                catch(Throwable throwable1)
                {
                    throwable.addSuppressed(throwable1);
                }
            else
                br.close();
            break MISSING_BLOCK_LABEL_113;
            Exception exception;
            exception;
            if(br != null)
                if(throwable != null)
                    try
                    {
                        br.close();
                    }
                    catch(Throwable throwable3)
                      {
                        throwable.addSuppressed(throwable3);
                    }
                else
                    br.close();
        throw exception;
        IOException ioexception;
        ioexception;
    }
}
</code></pre><p>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。</p>
<p>所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</p>
<h4 id="lambda表达式">Lambda表达式</h4>
<p>关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。</p>
<p>Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。</p>
<p>先来看一个简单的lambda表达式。遍历一个list：</p>
<pre><code>public static void main(String... args) {
    List&lt;String&gt; strList = ImmutableList.of(&quot;suxiansheng&quot;, &quot;Java&quot;, &quot;博客：www.jianshu.com/u/94111742c97c&quot;);

    strList.forEach( s -&gt; { System.out.println(s); } );
}
</code></pre><p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。</p>
<p>反编译后代码如下:</p>
<pre><code>public static /* varargs */ void main(String ... args) {
    ImmutableList strList = ImmutableList.of((Object)&quot;Java&quot;, (Object)&quot;\u516c\u4f17\u53f7\uff1aJava&quot;, (Object)&quot;\u535a\u5ba2\uff1awww.jianshu.com/u/94111742c97c&quot;);
    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());
}

private static /* synthetic */ void lambda$main$0(String s) {
    System.out.println(s);
}
</code></pre><p>可以看到，在forEach方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，
该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个lambda0方法进行了输出。</p>
<p>再来看一个稍微复杂一点的，先对List进行过滤，然后再输出：</p>
<pre><code>public static void main(String... args) {
    List&lt;String&gt; strList = ImmutableList.of(&quot;suxiansheng&quot;, &quot;Java, &quot;博客：www.jianshu.com/u/94111742c97c&quot;);

    List HollisList = strList.stream().filter(string -&gt; string.contains(&quot;Java&quot;)).collect(Collectors.toList());

    HollisList.forEach( s -&gt; { System.out.println(s); } );
}
</code></pre><p>反编译后代码如下：</p>
<pre><code>public static /* varargs */ void main(String ... args) {
    ImmutableList strList = ImmutableList.of((Object)&quot;Java&quot;, (Object)&quot;\u516c\u4f17\u53f7\uff1aJava&quot;, (Object)&quot;\u535a\u5ba2\uff1awww.jianshu.com/u/94111742c97c&quot;);
    List&lt;Object&gt; HollisList = strList.stream().filter((Predicate&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());
    HollisList.forEach((Consumer&lt;Object&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());
}

private static /* synthetic */ void lambda$main$1(Object s) {
    System.out.println(s);
}

private static /* synthetic */ boolean lambda$main$0(String string) {
    return string.contains(&quot;Hollis&quot;);
}
</code></pre><p>两个lambda表达式分别调用了lambda1和lambda0两个方法。</p>
<p>所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。</p>
<h3 id="可能遇到的坑">可能遇到的坑</h3>
<h4 id="泛型当泛型遇到重载">泛型——当泛型遇到重载</h4>
<pre><code>public class GenericTypes {

    public static void method(List&lt;String&gt; list) {  
        System.out.println(&quot;invoke method(List&lt;String&gt; list)&quot;);  
    }  

    public static void method(List&lt;Integer&gt; list) {  
        System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;);  
    }  
} 
</code></pre><p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List另一个是List，
但是，这段代码是编译通不过的。因为我们前面讲过，参数List和List编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。</p>
<h4 id="泛型当泛型遇到catch">泛型——当泛型遇到catch</h4>
<p>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的</p>
<p>泛型——当泛型内包含静态变量</p>
<pre><code>public class StaticTest{
    public static void main(String[] args){
        GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;();
        gti.var=1;
        GT&lt;String&gt; gts = new GT&lt;String&gt;();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT&lt;T&gt;{
    public static int var=0;
    public void nothing(T x){}
}
</code></pre><p>以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>
<h4 id="自动装箱与拆箱对象相等比较">自动装箱与拆箱——对象相等比较</h4>
<pre><code>public static void main(String[] args) {
    Integer a = 1000;
    Integer b = 1000;
    Integer c = 100;
    Integer d = 100;
    System.out.println(&quot;a == b is &quot; + (a == b));
    System.out.println((&quot;c == d is &quot; + (c == d)));
}
</code></pre><p>输出结果：</p>
<pre><code>a == b is false
c == d is true
</code></pre><p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<blockquote>
<p>适用于整数值区间<code>-128 至 +127</code>。只适用于自动装箱。使用构造函数创建对象不适用。</p>
</blockquote>
<h4 id="增强for循环">增强for循环</h4>
<pre><code>for (Student stu : students) {    
    if (stu.getId() == 2)     
        students.remove(stu);    
}
</code></pre><p>会抛出<code>ConcurrentModificationException</code>异常。</p>
<p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。
Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，
所以按照 <code>fail-fast</code> 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<p>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<h3 id="总结">总结</h3>
<ul>
<li>前面介绍了12种Java中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。</li>
<li>但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。</li>
<li>当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</li>
<li>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。</li>
</ul>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://whiteppure.github.io/myblog/tags/java/">Java</a>
                                    
                                    <a href="https://whiteppure.github.io/myblog/tags/%E8%BD%AC%E8%BD%BD/">转载</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>whitepure@2021</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/myblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/myblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/myblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/myblog/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>




<script src="https://cdn.bootcdn.net/ajax/libs/jspdf/1.0.106/jspdf.debug.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.js"></script>

<script type="text/javascript">
    var downPdf = document.getElementById("export_pdf");
    var pdfContent = document.getElementById('pdf_content');
    downPdf.onclick = () => {
        html2canvas(pdfContent, {
            onrendered:function(canvas) {

                var contentWidth = canvas.width;
                var contentHeight = canvas.height;

                
                

                var pageHeight = contentWidth / 592.28 * 841.89;
                
                var leftHeight = contentHeight;
                
                var position = 0;
                
                
                

                var imgWidth = 595.28;
                var imgHeight = 585.28/contentWidth * contentHeight;

                var pageData = canvas.toDataURL('image/jpeg', 1.0);

                var pdf = new jsPDF('', 'pt', 'a4');

                
                

                
                
                if (leftHeight < pageHeight) {
                    pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight );
                } else {
                    while(leftHeight > 0) {
                        pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight)
                        leftHeight -= pageHeight;
                        position -= 841.89;
                        
                        if(leftHeight > 0) {
                            pdf.addPage();
                        }
                    }
                }

                pdf.save('whitepure_blog.pdf');
            }
        })
    }
</script>
</body>

</html>