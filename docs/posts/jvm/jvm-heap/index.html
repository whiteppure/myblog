<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>堆 ｜ whitepure</title>
	
    
    
    <meta name="description" content="" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	
    
    <link rel="shortcut icon" href="https://whiteppure.github.io/myblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div class="toc">

    <div class="page-header"><strong>- CATALOG -</strong></div>

    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a0%86%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5">
                    堆的核心概念
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a0%86%e5%86%85%e5%ad%98%e7%bb%86%e5%88%86">
                    堆内存细分
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%ae%be%e7%bd%ae%e5%a0%86%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f">
                    设置堆内存大小
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%9f%a5%e7%9c%8b%e5%a0%86%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f">
                    查看堆内存大小
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#-xxprintgcdetails">
                    -XX:&#43;PrintGCDetails
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#jstat--gc">
                    jstat -gc
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#oom">
                    OOM
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b9%b4%e8%bd%bb%e4%bb%a3%e4%b8%8e%e8%80%81%e5%b9%b4%e4%bb%a3">
                    年轻代与老年代
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#-xxnewratio">
                    -XX:NewRatio
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#-xxsurvivorratio">
                    -XX:SurvivorRatio
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98">
                    为对象分配内存
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    
    <div class="main animate__animated animate__fadeInDown" id="pdf_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/myblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/myblog/" style="width: 100%">
                    <span>whitepure</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">大道至简</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/whiteppure/" title="github" target="_blank">
                    <i class="ri-github-fill"></i>
                </a>
                
                
                <a href="https://whiteppure.github.io/myblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                <button id="export_pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 4px">
                    <svg t="1614337230032" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2940" width="10" height="10"><path d="M825.202759 488.292634L584.527448 244.926676v484.916965c0 40.197297-32.584386 72.774621-72.781682 72.774621-40.190234 0-72.767559-32.577324-72.767559-72.774621V245.654069L197.999228 490.404193c-27.68331 28.29771-73.071228 28.784993-101.368938 1.094621a74.526014 74.526014 0 0 1-1.094621-105.168331L454.182841 22.076028a70.182841 70.182841 0 0 1 63.8976-19.067587 70.8608 70.8608 0 0 1 52.111007 21.179145l356.973462 360.977655c28.156469 28.608441 28.156469 74.518952 0 103.127393-27.662124 28.156469-72.915862 28.559007-101.065269 0.896883a53.699972 53.699972 0 0 1-0.896882-0.896883m123.211917 532.663614H75.083917c-40.190234 0-72.774621-32.584386-72.77462-72.781682v-145.556304c0-40.197297 32.59851-72.767559 72.788744-72.760496 40.183172 0.007062 72.753434 32.577324 72.767559 72.760496v72.774621h727.774455v-72.774621c0-40.197297 32.584386-72.774621 72.774621-72.774621 40.197297 0 72.774621 32.577324 72.774621 72.774621v145.556304c0 40.197297-32.577324 72.781683-72.774621 72.781682" fill="#707070" p-id="2941"></path></svg>
                </button>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/myblog/posts/jvm/jvm-heap/'>堆</a></h2>
                        <span class="date">2021.04.03</span>
                    </div>
                    <div class="post_content markdown"><h2 id="堆的核心概念">堆的核心概念</h2>
<p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。
一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存的大小是可以调节的。</p>
<blockquote>
<p>-Xms10m：最小堆内存</p>
<p>-Xmx10m：最大堆内存</p>
</blockquote>
<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p>
<blockquote>
<p>The heap is the run-time data area from which memory for all class instances and arrays is allocated</p>
</blockquote>
<p>“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。因为还有一些对象是在栈上分配的。</p>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<ul>
<li>也就是触发了GC的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，一个方法频繁的调用频繁的回收程序性能会收到影响</li>
</ul>
<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
<img src="/myblog/posts/images/essays/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png" alt="堆内存分配"></p>
<h2 id="堆内存细分">堆内存细分</h2>
<p><img src="/myblog/posts/images/essays/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="堆内存划分"></p>
<p>Java 7及之前<strong>堆内存逻辑</strong>上分为三部分：新生区+养老区+永久区</p>
<ul>
<li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区</li>
<li>Permanent Space永久区</li>
</ul>
<p>Java 8及之后<strong>堆内存逻辑</strong>上分为三部分：新生区+养老区+元空间</p>
<ul>
<li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区</li>
<li>Meta Space 元空间</li>
</ul>
<p>堆空间内部结构，JDK1.8之前从 永久代 替换成 元空间。</p>
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8之前.png" alt="jvm1.8之前">
</div>
<div style="width: 45%;display: inline-block">
    <img src="/myblog/posts/images/essays/jvm1.8.png" alt="jvm1.8">
</div>
<h2 id="设置堆内存大小">设置堆内存大小</h2>
<p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项&quot;-Xmx&quot;和&quot;-Xms&quot;来进行设置。</p>
<blockquote>
<p>“-Xms&quot;用于表示堆区的起始内存，等价于-xx:InitialHeapSize
“-Xmx&quot;则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p>
</blockquote>
<p><em>默认情况下,初始堆内存大小：物理电脑内存大小/64;最大堆内存大小：物理电脑内存大小/4</em>。</p>
<blockquote>
<p>在生产环境和开发环境，通常会将-Xms和-Xmx两个参数配置相同的值，
其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p>
</blockquote>
<p>使用代码查看</p>
<pre><code>public class MainTest {
    public static void main(String[] args) {
        // 返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        // 返回Java虚拟机试图使用的最大堆内存
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
        System.out.println(&quot;-Xms:&quot; + initialMemory + &quot;M&quot;);
        System.out.println(&quot;-Xmx:&quot; + maxMemory + &quot;M&quot;);
    }
}
</code></pre><h2 id="查看堆内存大小">查看堆内存大小</h2>
<h3 id="-xxprintgcdetails">-XX:+PrintGCDetails</h3>
<p>程序启动加入<code>-XX:+PrintGCDetails</code>参数</p>
<p><img src="/myblog/posts/images/essays/-XXPrintGCDetails.png" alt="-XXPrintGCDetails"></p>
<p><img src="/myblog/posts/images/essays/PrintGCDetails%E6%9F%A5%E7%9C%8B%E5%A0%86%E5%86%85%E5%AD%98.png" alt="-PrintGCDetails查看堆内存"></p>
<h3 id="jstat--gc">jstat -gc</h3>
<blockquote>
<p>jps  -&gt;  jstat -gc 进程ID</p>
</blockquote>
<p><img src="/myblog/posts/images/essays/jstat.png" alt="jstat"></p>
<h2 id="oom">OOM</h2>
<p>一旦堆区中的内存大小超过“-Xmx&quot;所指定的最大内存时，将会抛出<code>outOfMemoryError</code>异常。</p>
<p>代码实现</p>
<pre><code>public class MainTest {
    public static void main(String[] args) {
        ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();
        while (true){
//            try {
//                Thread.sleep(1000000);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
            list.add(new Picture(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Picture {
    private int data;
    public Picture(int data) {
        this.data = data;
    }
}
</code></pre><p><img src="/myblog/posts/images/essays/OOM.png" alt="OOM"></p>
<blockquote>
<p><code>jvisual</code> 工具在 jdk /bin/jvisualvm.exe
亦可在编译器 <a href="https://blog.csdn.net/qq_37960603/article/details/85224547">下载jvisual插件</a></p>
</blockquote>
<p>出现OOM错误后，可以通过 VisualVM 这个工具查看具体是什么参数造成的
<img src="/myblog/posts/images/essays/jvisual-OOM.png" alt="jvisual-OOM"></p>
<h2 id="年轻代与老年代">年轻代与老年代</h2>
<p>存储在JVM中的Java对象，按照生命周期可以被划分为两类：</p>
<p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，生命周期短的，及时回收；
另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</p>
<p>Java堆区进一步细分的话，可以划分为年轻代和老年代。
其中年轻代又可以划分为Eden区、Survivor0区和 Survivor1 区（有时也叫做from区、to区）。
<img src="/myblog/posts/images/essays/%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3.png" alt="年轻代与老年代"></p>
<blockquote>
<p>没有明确规定，to 区是 Survivor1；这两个区域是不断进行交换的；是从一个区到另外一个区</p>
</blockquote>
<p>测试用的代码,用于测试以下JVM参数</p>
<pre><code>public class MainTest {
    public static void main(String[] args) {
        System.out.println(&quot;start ...&quot;);
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id="-xxnewratio">-XX:NewRatio</h3>
<p>该参数是配置新生代与老年代在堆结构的占比。</p>
<p>默认情况下，新生代：老年代 - &gt; 1 : 2</p>
<ul>
<li>默认-XX:NewRatio=2；表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改-XX:NewRatio=4； 表示新生代占1，老年代占4，新生代占整个堆的1/5
<img src="/myblog/posts/images/essays/NewRatio.png" alt="NewRatio"></li>
</ul>
<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整年轻代与老年代的比例，来进行调优。</p>
<h3 id="-xxsurvivorratio">-XX:SurvivorRatio</h3>
<p>该命令是调整eden区与survivor区比例。这个参数一般使用默认值就可以了。</p>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，
当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如：-XX:SurvivorRatio=8。</p>
<blockquote>
<p>PS 在实际开发中使用hotspot虚拟机，默认情况下不是8：1：1；
是因为虚拟机有一个自适应内存分配策略，可以通过<code>-XX:-UseAdaptiveSizePolicy</code>关闭再来进行查看.
<img src="/myblog/posts/images/essays/SurvivorRatio.png" alt="SurvivorRatio"></p>
</blockquote>
<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>
<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
<p>可以使用选项&quot;-Xmn&quot;设置新生代最大内存大小。</p>
<blockquote>
<p>PS 当 -Xmn 参数与 -XX:NewRatio 设置的值发生冲突时，会以 -Xmn 设置的具体值为准。</p>
</blockquote>
<p><img src="/myblog/posts/images/essays/eden%E4%B8%8Esurvivor%E4%B8%8Etenured.png" alt="eden与survivor与tenured"></p>
<h2 id="为对象分配内存">为对象分配内存</h2>
<p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，
并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p>对象分配内存步骤：
<img src="/myblog/posts/images/essays/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" alt="对象内存分配策略"></p>
<ol>
<li>新的对象先放伊甸园区。此区有大小限制。(如果对象过大可能直接分配在老年代)</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行MinorGC，将伊甸园区中的不再被其他对象所引用的对象进行销毁。
再将新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发MinorGC，会首先将没有被回收的对象放到幸存者1区，然后判断幸存者0区中的对象是否能被回收，如果没有回收，就会放到幸存者1区。</li>
<li>重复步骤3、4，默认情况下如果一个对象被扫描了15次（阈值），都不能被回收，则将该对象晋升到老年代。</li>
<li>当老年代内存不足时，再次触发GC：Major GC，进行老年代的内存清理。</li>
<li>若老年代执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM错误。</li>
</ol>
<p><em>可以用 -XX:MaxTenuringThreshold=N  进行设置幸存者区到老年代的GC扫描次数，默认15次。</em></p>
<blockquote>
<p>PS 如果幸存者区满了？
如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。
<strong>需要特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</strong></p>
</blockquote>
<p>代码演示对象分配过程</p>
<pre><code>// -Xms600m -Xmx600m
public class HeapInstanceTest {
    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;HeapInstanceTest&gt; list = new ArrayList&lt;&gt;();
        while (true) {
            list.add(new HeapInstanceTest());
            Thread.sleep(10);
        }
    }
}
</code></pre><p>打开<code>VisualVM</code>图形化界面,通过<code>VisualGC</code>进行动态化查看
<img src="/myblog/posts/images/essays/%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.gif" alt="代码演示对象分配过程"></p>
<blockquote>
<p>总结：</p>
<ul>
<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to区</li>
<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>
<li>新生代采用复制算法的目的：是为了减少内碎片</li>
</ul>
</blockquote>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://whiteppure.github.io/myblog/tags/java/">Java</a>
                                    
                                    <a href="https://whiteppure.github.io/myblog/tags/jvm/">JVM</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>whitepure@2021</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/myblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/myblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/myblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/myblog/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>




<script src="https://cdn.bootcdn.net/ajax/libs/jspdf/1.0.106/jspdf.debug.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.js"></script>

<script type="text/javascript">
    var downPdf = document.getElementById("export_pdf");
    var pdfContent = document.getElementById('pdf_content');
    downPdf.onclick = () => {
        html2canvas(pdfContent, {
            onrendered:function(canvas) {

                var contentWidth = canvas.width;
                var contentHeight = canvas.height;

                
                

                var pageHeight = contentWidth / 592.28 * 841.89;
                
                var leftHeight = contentHeight;
                
                var position = 0;
                
                
                

                var imgWidth = 595.28;
                var imgHeight = 585.28/contentWidth * contentHeight;

                var pageData = canvas.toDataURL('image/jpeg', 1.0);

                var pdf = new jsPDF('', 'pt', 'a4');

                
                

                
                
                if (leftHeight < pageHeight) {
                    pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight );
                } else {
                    while(leftHeight > 0) {
                        pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight)
                        leftHeight -= pageHeight;
                        position -= 841.89;
                        
                        if(leftHeight > 0) {
                            pdf.addPage();
                        }
                    }
                }

                pdf.save('whitepure_blog.pdf');
            }
        })
    }
</script>
</body>

</html>