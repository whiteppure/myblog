<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>SpringBoot详解 ｜ whitepure</title>
	
    
    
    <meta name="description" content="" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	
    
    <link rel="shortcut icon" href="https://whiteppure.github.io/myblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/myblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div class="toc">

    <div class="page-header"><strong>- CATALOG -</strong></div>

    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a6%82%e8%bf%b0">
                    概述
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#springbootapplication">
                    @SpringBootApplication
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#springbootconfiguration">
                    @SpringBootConfiguration
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#enableautoconfiguration">
                    @EnableAutoConfiguration
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%80%bb%e7%bb%93">
                    总结
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d">
                    自动装配
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#autowired">
                    @Autowired
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8a%a0%e5%9c%a8%e5%b1%9e%e6%80%a7%e4%b8%8a">
                    加在属性上
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8a%a0%e5%9c%a8%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e4%b8%8a">
                    加在方法、参数上
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8e%9f%e7%90%86">
                    原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#resourceinject">
                    @Resource、@Inject
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8spring%e5%ba%95%e5%b1%82%e7%bb%84%e4%bb%b6">
                    使用Spring底层组件
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    
    <div class="main animate__animated animate__fadeInDown" id="pdf_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/myblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/myblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/myblog/" style="width: 100%">
                    <span>whitepure</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">大道至简</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/whiteppure/" title="github" target="_blank">
                    <i class="ri-github-fill"></i>
                </a>
                
                
                <a href="https://whiteppure.github.io/myblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                <button id="export_pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 4px">
                    <svg t="1614337230032" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2940" width="10" height="10"><path d="M825.202759 488.292634L584.527448 244.926676v484.916965c0 40.197297-32.584386 72.774621-72.781682 72.774621-40.190234 0-72.767559-32.577324-72.767559-72.774621V245.654069L197.999228 490.404193c-27.68331 28.29771-73.071228 28.784993-101.368938 1.094621a74.526014 74.526014 0 0 1-1.094621-105.168331L454.182841 22.076028a70.182841 70.182841 0 0 1 63.8976-19.067587 70.8608 70.8608 0 0 1 52.111007 21.179145l356.973462 360.977655c28.156469 28.608441 28.156469 74.518952 0 103.127393-27.662124 28.156469-72.915862 28.559007-101.065269 0.896883a53.699972 53.699972 0 0 1-0.896882-0.896883m123.211917 532.663614H75.083917c-40.190234 0-72.774621-32.584386-72.77462-72.781682v-145.556304c0-40.197297 32.59851-72.767559 72.788744-72.760496 40.183172 0.007062 72.753434 32.577324 72.767559 72.760496v72.774621h727.774455v-72.774621c0-40.197297 32.584386-72.774621 72.774621-72.774621 40.197297 0 72.774621 32.577324 72.774621 72.774621v145.556304c0 40.197297-32.577324 72.781683-72.774621 72.781682" fill="#707070" p-id="2941"></path></svg>
                </button>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/myblog/posts/spring/java-springboot/'>SpringBoot详解</a></h2>
                        <span class="date">2021.05.13</span>
                    </div>
                    <div class="post_content markdown"><h2 id="概述">概述</h2>
<p>官网地址：<a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p>
<blockquote>
<p><code>SpringBoot</code>是由<code>Pivotal</code>团队提供的全新框架，其设计目的是用来简化新<code>Spring</code>应用的初始搭建以及开发过程。
该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。<code>SpringBoot</code> 提供了一种新的编程范式，可以更加快速便捷地开发 <code>Spring</code> 项目，在开发过程当中可以专注于应用程序本身的功能开发，而无需在 <code>Spring</code> 配置上花太大的工夫。</p>
</blockquote>
<p><code>SpringBoot</code> 基于 <code>Sring4</code> 进行设计，继承了原有 <code>Spring</code> 框架的优秀基因。
<code>SpringBoot</code> 准确的说并不是一个框架，而是一些类库的集合。
<code>maven</code> 或者 <code>gradle</code> 项目导入相应依赖即可使用 <code>SpringBoot</code>，而无需自行管理这些类库的版本。</p>
<p>特点：</p>
<ul>
<li>
<p>独立运行的 <code>Spring</code> 项目<br>
<code>SpringBoot</code> 可以以 jar 包的形式独立运行，运行一个 <code>SpringBoot</code> 项目只需通过 <code>java–jar xx.jar</code> 来运行。</p>
</li>
<li>
<p>内嵌 Servlet 容器<br>
<code>SpringBoot</code> 可选择内嵌 <code>Tomcat</code>、<code>Jetty</code> 或者 <code>Undertow</code>，这样我们无须以 <code>war</code> 包形式部署项目。</p>
</li>
<li>
<p>提供 <code>starter</code> 简化 <code>Maven</code> 配置<br>
<code>Spring</code> 提供了一系列的 <code>starter</code> pom 来简化 <code>Maven</code> 的依赖加载，例如，当你使用了<code>spring-boot-starter-web</code> 时，会自动加入依赖包。</p>
</li>
<li>
<p>自动配置 <code>Spring</code><br>
<code>SpringBoot</code> 会根据在类路径中的 jar 包、类，为 jar 包里的类自动配置 Bean，这样会极大地减少我们要使用的配置。当然，<code>SpringBoot</code> 只是考虑了大多数的开发场景，并不是所有的场景，若在实际开发中我们需要自动配置 <code>Bean</code>，而 <code>SpringBoot</code> 没有提供支持，则可以自定义自动配置。</p>
</li>
<li>
<p>准生产的应用监控<br>
<code>SpringBoot</code> 提供基于 <code>http、ssh、telnet</code> 对运行时的项目进行监控。</p>
</li>
<li>
<p>无代码生成和 xml 配置<br>
<code>SpringBoot</code> 的神奇的不是借助于代码生成来实现的，而是通过条件注解来实现的，这是 <code>Spring 4.x</code> 提供的新特性。<code>Spring 4.x</code> 提倡使用 Java 配置和注解配置组合，而 <code>SpringBoot</code> 不需要任何 xml 配置即可实现 <code>Spring</code> 的所有配置。</p>
</li>
</ul>
<h2 id="springbootapplication">@SpringBootApplication</h2>
<p>这个注解在启动类上</p>
<pre><code>@SpringBootApplication
public class SpringBootExampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringBootExampleApplication.class, args);
    }
}
</code></pre><p><code>@SpringBootApplication</code>是一个复合注解，由其他注解构成。核心注解是<code>@SpringBootConfiguration</code>和<code>@EnableAutoConfiguration</code></p>
<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication{
}
</code></pre><h3 id="springbootconfiguration">@SpringBootConfiguration</h3>
<p><code>@SpringBootConfiguration</code>核心注解是<code>@Configuration</code>代表自己是一个<code>Spring</code>的配置类</p>
<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration {
}
</code></pre><p><code>@Configuration</code>底层实现就是一个<code>Component</code></p>
<blockquote>
<p>指示带注释的类是一个“组件”。
在使用基于注释的配置和类路径扫描时，这些类被视为自动检测的候选类。</p>
</blockquote>
<pre><code>/**
 * Indicates that an annotated class is a &quot;component&quot;.
 * Such classes are considered as candidates for auto-detection
 * when using annotation-based configuration and classpath scanning.
 *
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component 
</code></pre><h3 id="enableautoconfiguration">@EnableAutoConfiguration</h3>
<p>核心注解是<code>@AutoConfigurationPackage</code>和<code>@Import({AutoConfigurationImportSelector.class})</code></p>
<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
}
</code></pre><p><code>@AutoConfigurationPackage</code>注解核心是引入了一个<code>@Import(AutoConfigurationPackages.Registrar.class)</code>配置类,该类实现了<code>ImportBeanDefinitionRegistrar</code>接口</p>
<pre><code>	/**
	 * {@link ImportBeanDefinitionRegistrar} to store the base package from the importing
	 * configuration.
	 */
	static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
		@Override
		public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
			register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));
		}
		@Override
		public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) {
			return Collections.singleton(new PackageImports(metadata));
		}

	}
</code></pre><blockquote>
<p>这里可以打断点自己看一下</p>
</blockquote>
<p><code>@AutoConfigurationPackage</code> 这个注解本身的含义就是将主配置类（<code>@SpringBootApplication</code>标注的类）所在的包下面所有的组件都扫描到 <code>spring</code> 容器中。</p>
<p><code>AutoConfigurationImportSelector</code>核心代码如下</p>
<pre><code>	/**
	 * Return the auto-configuration class names that should be considered. By default
	 * this method will load candidates using {@link SpringFactoriesLoader} with
	 * {@link #getSpringFactoriesLoaderFactoryClass()}.
	 * @param metadata the source metadata
	 * @param attributes the {@link #getAttributes(AnnotationMetadata) annotation
	 * attributes}
	 * @return a list of candidate configurations
	 */
	protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
				getBeanClassLoader());
		Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
				+ &quot;are using a custom packaging, make sure that file is correct.&quot;);
		return configurations;
	}

	/**
	 * Return the class used by {@link SpringFactoriesLoader} to load configuration
	 * candidates.
	 * @return the factory class
	 */
	protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() {
		return EnableAutoConfiguration.class;
	}
	protected ClassLoader getBeanClassLoader() {
		return this.beanClassLoader;
	}
</code></pre><p><code>getSpringFactoriesLoaderFactoryClass</code>方法返回<code>EnableAutoConfiguration.class</code>目的就是为了将启动类所需的所有资源导入。</p>
<p>在<code>getCandidateConfigurations</code>中有如下代码</p>
<pre><code>Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
</code></pre><p>大意：在<code>META-INF/spring.factories</code>中没有发现自动配置类。如果您使用的是自定义打包，请确保该文件是正确的。
<img src="/myblog/posts/images/essays/%E6%89%BE%E5%88%B0spring.factories.png" alt="找到spring.factories"></p>
<p><code>spring.factories</code>包含了很多类，但不是全部都加载的，在某些类里面，是有一个条件<code>@ConditionalOnXXX</code>注解，只有当这个注解上的条件满足才会加载。</p>
<p>例如：<code>SpringApplicationAdminJmxAutoConfiguration</code></p>
<pre><code>@Configuration(proxyBeanMethods = false)
@AutoConfigureAfter(JmxAutoConfiguration.class)
@ConditionalOnProperty(prefix = &quot;spring.application.admin&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;,
		matchIfMissing = false)
public class SpringApplicationAdminJmxAutoConfiguration 
</code></pre><h3 id="总结">总结</h3>
<p><img src="/myblog/posts/images/essays/@SpringbootApplication%E5%8E%9F%E7%90%86.png" alt="@SpringbootApplication原理"></p>
<p>当Springboot启动的时候，会执行<code>AutoConfigurationImportSelector</code>这个类中的<code>getCandidateConfigurations</code>方法，这个方法会帮我们加载<code>META-INF/spring.factories</code>文件里面的当<code>@ConditionXXX</code>注解条件满足的类。</p>
<h2 id="自动装配">自动装配</h2>
<p><code>Spring</code>利用依赖注入（DI），完成对IOC容器中各个组件的依赖关系赋值。</p>
<p>Spring提供三种装配方式：</p>
<ul>
<li>基于注解的自动装配</li>
<li>基于XML配置的显式装配</li>
<li>基于Java配置的显式装配</li>
</ul>
<p>详细本篇博客，详细介绍基于注解的自动装配</p>
<table>
<thead>
<tr>
<th>自动装配</th>
<th>来源</th>
<th>支持@Primary</th>
<th>springboot支持属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Autowired</td>
<td>Springboot原生</td>
<td>支持</td>
<td>boolean required</td>
</tr>
<tr>
<td>@Resource</td>
<td>JSR-250，JDK自带</td>
<td>不支持</td>
<td>无其他属性</td>
</tr>
<tr>
<td>@Inject</td>
<td>JSR-330，需要导入javax.inject</td>
<td>支持</td>
<td>无其他属性</td>
</tr>
</tbody>
</table>
<h3 id="autowired">@Autowired</h3>
<p>可以放在构造器、参数、方法、属性上</p>
<p>源码如下：</p>
<pre><code>@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {

	/**
	 * Declares whether the annotated dependency is required.
	 * &lt;p&gt;Defaults to {@code true}.
	 */
	boolean required() default true;

}
</code></pre><h4 id="加在属性上">加在属性上</h4>
<p>使用<code>@Autowired</code>注解通常将其加载属性上或者构造器上，让其自动注入；
默认是按照类型去容器中寻找对应的组件，例如：</p>
<pre><code>
public class SpringBootExampleApplication {


    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);

        TestService testService = annotationConfigApplicationContext.getBean(TestService.class);
        // TestService 实例=====&gt;TestService(testDao=TestDao(name=default))
        System.out.println(&quot;TestService 实例=====&gt;&quot; +testService);

    }

}


// 扫描的包名称
@ComponentScan({&quot;com.example.springboot.example.task&quot;})
@Configuration
class TestConfig{

}


@ToString
@Service
class TestService {

    @Autowired
    TestDao testDao;

}

@ToString
@Repository
class TestDao{

    @Getter
    @Setter
    private String name = &quot;default&quot;;

}
</code></pre><p>如果容器中有多个组件的名称相同,可以通过<code>@Qualifier</code>来进行选择注入；</p>
<pre><code>public class SpringBootExampleApplication {


    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);

        TestService testService = annotationConfigApplicationContext.getBean(TestService.class);
        // TestService 实例=====&gt;TestService(testDao=TestDao(name=我是默认的TestDao))
        System.out.println(&quot;TestService 实例=====&gt;&quot; +testService);

    }

}


@ComponentScan({&quot;com.example.springboot.example.task&quot;})
@Configuration
class TestConfig{

    @Bean(name = &quot;testDao2&quot;)
     public TestDao testDao(){
        TestDao testDao = new TestDao();
        testDao.setName(&quot;我是testDao2&quot;);
        return testDao;
    }
}

@ToString
@Service
class TestService {

    @Autowired
    @Qualifier(&quot;testDao&quot;)
    TestDao testDao;

}

@ToString
@Repository
class TestDao{

    @Getter
    @Setter
    private String name = &quot;我是默认的TestDao&quot;;

}
</code></pre><p>除了使用<code>@Qualifier</code>来进行选择注入外，也可以使用<code>@Primary</code>来设置 bean 的优先级，默认情况下指定让哪个 bean 优先注入；</p>
<p><code>@Primary</code>注解是在没有明确指定的情况下，默认使用的 bean，如果你明确用<code>@Qualifier</code>指定，则会使用<code>@Qualifier</code>指定的bean；
确保测试结果准确，在使用<code>@Primary</code>时，将<code>@Qualifier</code>去掉。</p>
<pre><code>public class SpringBootExampleTaskApplication {


    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);

        TestService testService = annotationConfigApplicationContext.getBean(TestService.class);
//        TestService 实例=====&gt;TestService(testDao=TestDao(name=我是testDao2))
        System.out.println(&quot;TestService 实例=====&gt;&quot; +testService);

    }

}


@ComponentScan({&quot;com.example.springboot.example.task&quot;})
@Configuration
class TestConfig{

    @Primary
    @Bean(name = &quot;testDao2&quot;)
     public TestDao testDao(){
        TestDao testDao = new TestDao();
        testDao.setName(&quot;我是testDao2&quot;);
        return testDao;
    }
}

@ToString
@Service
class TestService {

    @Autowired
    TestDao testDao;

}

@ToString
@Repository
class TestDao{

    @Getter
    @Setter
    private String name = &quot;我是默认的TestDao&quot;;

}
</code></pre><p>如果使用<code>@Autowired</code>在容器中没有对应的组件名称，默认情况下会报错。</p>
<pre><code>nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: ...
</code></pre><p>如果没有找到对应的 bean 不报错，可以通过<code>@Autowired(required = false)</code>来进行设置</p>
<pre><code>@ToString
@Service
class TestService {
    
    // TestService 实例=====&gt;TestService(testDao=null)

    @Autowired(required = false)
    TestDao testDao;

}
</code></pre><h4 id="加在方法参数上">加在方法、参数上</h4>
<p><code>@Autowired</code>注解不仅可以标注在属性上，也可以标注在方法上，当标注在方法上时，Spring容器创建当前对象，就会调用该方法完成赋值，方法使用的参数从IOC容器中获取。</p>
<p>通过测试打印对象的地址可以看到，方法中的参数确实是从IOC容器中获取的。</p>
<pre><code>public class SpringBootExampleTaskApplication {


    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);

        TestService testService = annotationConfigApplicationContext.getBean(TestService.class);
        System.out.println(&quot;TestService 中的实例=====&gt;&quot; +testService);

        TestDao testDao = annotationConfigApplicationContext.getBean(TestDao.class);
        System.out.println(&quot;TestDao 中的实例=====&gt;&quot; +testDao);
        
        // TestService 中的实例=====&gt;TestService(testDao=com.example.springboot.example.task.TestDao@5fe94a96)
        //TestDao 中的实例=====&gt;com.example.springboot.example.task.TestDao@5fe94a96


    }

}


@ComponentScan({&quot;com.example.springboot.example.task&quot;})
@Configuration
class TestConfig{
}

@ToString
@Service
class TestService {


    TestDao testDao;

    @Autowired
    public void setTestDao(TestDao testDao) {
        this.testDao = testDao;
    }
}


@Repository
class TestDao{

    private String name = &quot;我是默认的TestDao&quot;;

}
</code></pre><p>也可以加在参数上，与加在方法上类似也是从IOC容器中获取该对象。</p>
<pre><code>@ToString
@Service
class TestService {


    TestDao testDao;

    public void setTestDao(@Autowired TestDao testDao) {
        this.testDao = testDao;
    }
}
</code></pre><p>在Spring创建对象的时候会默认调用组件的无参构造方法，如果只有一个有参构造，如果想要创建对象，则必须调用该有参构造；
所以当一个组件只有一个有参构造时，则可以不用写<code>@Autowirea</code>注解。</p>
<pre><code>@ToString
@Service
class TestService {


    TestDao testDao;
    
     // @Autowired
    public TestService(TestDao testDao) {
        this.testDao = testDao;
    }

}
</code></pre><p>除了通过构造方法的方式实例化组件，也可以通过用bean标注的形式，来实例化容器中的组件。</p>
<pre><code>public class SpringBootExampleTaskApplication {


    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);

        TestService testService = annotationConfigApplicationContext.getBean(TestService.class);
        System.out.println(&quot;TestService 中的实例=====&gt;&quot; +testService);

        TestDao testDao = annotationConfigApplicationContext.getBean(TestDao.class);
        System.out.println(&quot;TestDao 中的实例=====&gt;&quot; +testDao);

        TestDao1 testDao1 = annotationConfigApplicationContext.getBean(TestDao1.class);
        System.out.println(&quot;TestDao1 中的实例=====&gt;&quot; +testDao);
        
        // TestService 中的实例=====&gt;TestService(testDao=com.example.springboot.example.task.TestDao@639c2c1d)
        //TestDao 中的实例=====&gt;com.example.springboot.example.task.TestDao@639c2c1d
        //TestDao1 中的实例=====&gt;com.example.springboot.example.task.TestDao@639c2c1d

    }

}


@ComponentScan({&quot;com.example.springboot.example.task&quot;})
@Configuration
class TestConfig{

    @Bean
    public TestDao1 testDao1(TestDao testDao){
        TestDao1 testDao1 = new TestDao1();
        testDao1.setTestDao(testDao);
        return testDao1;
    }
}

@ToString
@Service
class TestService {


    TestDao testDao;

    @Autowired
    public TestService(TestDao testDao) {
        this.testDao = testDao;
    }

}


@Component
class TestDao{
}

class TestDao1{
    @Setter
    TestDao testDao;
}
</code></pre><h4 id="原理">原理</h4>
<ul>
<li><code>Spring</code> 容器启动时，<code>AutowiredAnnotationBeanPostProcessor</code> 被注册到容器中；</li>
<li>扫描代码，如果带有 <code>@Autowired</code> 注解，则将依赖注入信息封装到 <code>InjectionMetadata</code> 中;</li>
<li>创建 <code>bean</code> 也就是实例化对象和初始化，会调用各种 <code>BeanPostProcessor</code> 对 <code>bean</code> 初始化，<code>AutowiredAnnotationBeanPostProcessor</code> 负责将相关的依赖注入进来；</li>
</ul>
<p><code>@Autowired</code>注解调用栈：</p>
<pre><code>AbstractApplicationContext.refresh(容器初始化)
---&gt; registerBeanPostProcessors (注册AutowiredAnnotationBeanPostProcessor) 
---&gt; finishBeanFactoryInitialization 
---&gt; AbstractAutowireCapableBeanFactory.doCreateBean
---&gt; AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors
---&gt; MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition
---&gt; AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata
---&gt; InjectionMetadata.checkConfigMembers
</code></pre><p>核心方法<code>findAutowiringMetadata</code></p>
<pre><code>private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, @Nullable PropertyValues pvs) {
		// Fall back to class name as cache key, for backwards compatibility with custom callers.
		String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
		// Quick check on the concurrent map first, with minimal locking.
		InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
		if (InjectionMetadata.needsRefresh(metadata, clazz)) {
			synchronized (this.injectionMetadataCache) {
				metadata = this.injectionMetadataCache.get(cacheKey);
				if (InjectionMetadata.needsRefresh(metadata, clazz)) {
					if (metadata != null) {
						metadata.clear(pvs);
					}
					metadata = buildAutowiringMetadata(clazz);
					this.injectionMetadataCache.put(cacheKey, metadata);
				}
			}
		}
		return metadata;
	}



private InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) {
		LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = new LinkedList&lt;&gt;();
		Class&lt;?&gt; targetClass = clazz;//需要处理的目标类
       
		do {
			final LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = new LinkedList&lt;&gt;();
 
            /*通过反射获取该类所有的字段，并遍历每一个字段，并通过方法findAutowiredAnnotation遍历每一个字段的所用注解，并如果用autowired修饰了，则返回auotowired相关属性*/  
 
			ReflectionUtils.doWithLocalFields(targetClass, field -&gt; {
				AnnotationAttributes ann = findAutowiredAnnotation(field);
				if (ann != null) {//校验autowired注解是否用在了static方法上
					if (Modifier.isStatic(field.getModifiers())) {
						if (logger.isWarnEnabled()) {
							logger.warn(&quot;Autowired annotation is not supported on static fields: &quot; + field);
						}
						return;
					}//判断是否指定了required
					boolean required = determineRequiredStatus(ann);
					currElements.add(new AutowiredFieldElement(field, required));
				}
			});
            //和上面一样的逻辑，但是是通过反射处理类的method
			ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; {
				Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
				if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
					return;
				}
				AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);
				if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
					if (Modifier.isStatic(method.getModifiers())) {
						if (logger.isWarnEnabled()) {
							logger.warn(&quot;Autowired annotation is not supported on static methods: &quot; + method);
						}
						return;
					}
					if (method.getParameterCount() == 0) {
						if (logger.isWarnEnabled()) {
							logger.warn(&quot;Autowired annotation should only be used on methods with parameters: &quot; +
									method);
						}
					}
					boolean required = determineRequiredStatus(ann);
					PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
              	    currElements.add(new AutowiredMethodElement(method, required, pd));
				}
			});
    //用@Autowired修饰的注解可能不止一个，因此都加在currElements这个容器里面，一起处理		
			elements.addAll(0, currElements);
			targetClass = targetClass.getSuperclass();
		}
		while (targetClass != null &amp;&amp; targetClass != Object.class);
 
		return new InjectionMetadata(clazz, elements);
	}


</code></pre><p><code>checkConfigMembers</code>方法</p>
<pre><code>public void checkConfigMembers(RootBeanDefinition beanDefinition) {
		Set&lt;InjectedElement&gt; checkedElements = new LinkedHashSet&lt;&gt;(this.injectedElements.size());
		for (InjectedElement element : this.injectedElements) {
			Member member = element.getMember();
			if (!beanDefinition.isExternallyManagedConfigMember(member)) {
				beanDefinition.registerExternallyManagedConfigMember(member);
				checkedElements.add(element);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Registered injected element on class [&quot; + this.targetClass.getName() + &quot;]: &quot; + element);
				}
			}
		}
		this.checkedElements = checkedElements;
	}
</code></pre><h3 id="resourceinject">@Resource、@Inject</h3>
<p>Spring 自动装配除了<code>@Autowired</code>注解外，也支持JSR-250中的<code>@Resource</code>和JSR-330中的<code>@Inject</code>注解，来进行自动装配；</p>
<pre><code>public class SpringBootExampleTaskApplication {


    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);

        TestService testService = annotationConfigApplicationContext.getBean(TestService.class);
//        TestService 实例=====&gt;TestService(testDao=TestDao(name=我是默认的TestDao))
        System.out.println(&quot;TestService 实例=====&gt;&quot; +testService);

    }

}


@ComponentScan({&quot;com.example.springboot.example.task&quot;})
@Configuration
class TestConfig{

    @Bean(name = &quot;testDao2&quot;)
     public TestDao testDao(){
        TestDao testDao = new TestDao();
        testDao.setName(&quot;我是testDao2&quot;);
        return testDao;
    }
}

@ToString
@Service
class TestService {


    @Resource
    TestDao testDao;

}


@ToString
@Repository
class TestDao{

    @Getter
    @Setter
    private String name = &quot;我是默认的TestDao&quot;;

}
</code></pre><p>使用<code>@Inject</code>注解需要导入</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><pre><code>@ToString
@Service
class TestService {

    // TestService 实例=====&gt;TestService(testDao=TestDao(name=我是默认的TestDao))
    @Inject
    TestDao testDao;

}
</code></pre><h3 id="使用spring底层组件">使用Spring底层组件</h3>
<p>通过实现<code>Aware</code>接口的子接口，来使用Spring的底层的组件。<code>Aware</code>接口类似于回调方法的形式在 Spring 加载的时候将我们自定以的组件加载。</p>
<pre><code>/**
 * A marker superinterface indicating that a bean is eligible to be notified by the
 * Spring container of a particular framework object through a callback-style method.
 * The actual method signature is determined by individual subinterfaces but should
 * typically consist of just one void-returning method that accepts a single argument.
 */
public interface Aware {

}
</code></pre><p><img src="/myblog/posts/images/essays/Aware%E5%AD%90%E6%8E%A5%E5%8F%A3.png" alt="Aware子接口"></p>
<p>使用测试</p>
<pre><code>@Component
class TestService implements ApplicationContextAware, EmbeddedValueResolverAware, BeanFactoryAware {

    public TestService() {
    }

    ApplicationContext applicationContext;


    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;获取实例名称===&gt;&quot; + beanFactory.getBean(&quot;TestService&quot;));
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        System.out.println(&quot;获取容器对象===&gt; &quot;+ applicationContext);
    }

    @Override
    public void setEmbeddedValueResolver(StringValueResolver resolver) {
        System.out.println(resolver.resolveStringValue(&quot;我是${os.name}，今年${10*2.1}岁&quot;));
    }
}
</code></pre><p>关于这些<code>Aware</code>都是使用<code>AwareProcessor</code>进行处理的；比如:<code>ApplicationContextAwareProcessor</code>就是处理<code>ApplicationContextAware</code>接口的。</p>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://whiteppure.github.io/myblog/tags/java/">Java</a>
                                    
                                    <a href="https://whiteppure.github.io/myblog/tags/springboot/">springboot</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>whitepure@2021</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/myblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/myblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/myblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/myblog/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>




<script src="https://cdn.bootcdn.net/ajax/libs/jspdf/1.0.106/jspdf.debug.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.js"></script>

<script type="text/javascript">
    var downPdf = document.getElementById("export_pdf");
    var pdfContent = document.getElementById('pdf_content');
    downPdf.onclick = () => {
        html2canvas(pdfContent, {
            onrendered:function(canvas) {

                var contentWidth = canvas.width;
                var contentHeight = canvas.height;

                
                

                var pageHeight = contentWidth / 592.28 * 841.89;
                
                var leftHeight = contentHeight;
                
                var position = 0;
                
                
                

                var imgWidth = 595.28;
                var imgHeight = 585.28/contentWidth * contentHeight;

                var pageData = canvas.toDataURL('image/jpeg', 1.0);

                var pdf = new jsPDF('', 'pt', 'a4');

                
                

                
                
                if (leftHeight < pageHeight) {
                    pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight );
                } else {
                    while(leftHeight > 0) {
                        pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight)
                        leftHeight -= pageHeight;
                        position -= 841.89;
                        
                        if(leftHeight > 0) {
                            pdf.addPage();
                        }
                    }
                }

                pdf.save('whitepure_blog.pdf');
            }
        })
    }
</script>
</body>

</html>